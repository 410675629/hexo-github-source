{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/GNAME","path":"GNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/GNAME","hash":"e4a86643263969cda8fea06a8ce5a80f2a727c71","modified":1502183547684},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1502178480852},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1502178480853},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1502178480854},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1502178480856},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1502178480855},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1502178480857},{"_id":"themes/yilia/webpack.config.js","hash":"14fe482547b12b15bc78cb981c42a4ca5b6ba770","modified":1502178481110},{"_id":"source/_posts/hexo-github-AppVeyor实现不同电脑写博客.md","hash":"d9e1336684e9ba50d87a117012c90bd8f74a9be1","modified":1502178480467},{"_id":"source/_posts/webpack总结-一.md","hash":"2acdbce303c5b2209a20b4ca47a6a4b2622d7cfe","modified":1507364425289},{"_id":"themes/yilia/package.json","hash":"4631f9013f0b1c5fc5d73af4c3624375bfe4d109","modified":1502178480893},{"_id":"source/_posts/jsonp使用及promise封装.md","hash":"ba1ac77adad7144aa3acff8f6d283f154e9ba793","modified":1507189973367},{"_id":"source/_posts/使用代理解决跨域限制.md","hash":"c0b3df9dad3d688f38d8754e591746cedff56589","modified":1507298261212},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1502178480859},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1502178480860},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1502178480861},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1502178480862},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1502178480864},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1502178480867},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1502178480865},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1502178480887},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1502178480887},{"_id":"themes/yilia/_config.yml","hash":"6ac9c113cab8f50096f2e8d53a1b0b6e32c48669","modified":1502178480858},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1502178480888},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502178480890},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502178480891},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1502178480892},{"_id":"source/_posts/swiper-animal-冲突解决.md","hash":"4c2929d820a4aae4cfc90810a4d0804f9e780d32","modified":1502178480468},{"_id":"themes/yilia/layout/layout.ejs","hash":"077f40edaab099490dbe9efeba1136dfe4b5f347","modified":1502197080746},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1502178480854},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1502178481110},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1502178480894},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1502178481094},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1502178480869},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1502178480870},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1502178480870},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1502178480873},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"6c4a76245ca2379cfc649aed3b07f1a7b867e4a7","modified":1502178480872},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1502178480875},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"c5173337832c29499311260be291e6c12a329079","modified":1502178480874},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"4767e666849ac2600c7a1cbf94c54cf702864f80","modified":1502178480871},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1502178480875},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1502178480876},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1502178480877},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1502178480877},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1502178480878},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"538b6d35b25cbdba7dc77feec638336625c8ef8b","modified":1502178480885},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1502178480886},{"_id":"themes/yilia/source/main.234bc0.css","hash":"0b505e2d152f71ae1c9c201f9a25c28c39d8f6d0","modified":1502197077651},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1502178481110},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1502178481094},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1502178480884},{"_id":"themes/yilia/source/slider.885efe.js","hash":"850271f829a57f60385a9807195965dcfdf4dfb6","modified":1502197098250},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502178481110},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1502178481110},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502178481110},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1502178481110},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1502178480895},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1502178480896},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"a664a5b474d15ab42422f38f24d3a9dcfe4c9e0e","modified":1502178480899},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"8a0ae8ee6af8df3f215f1cd4ecc10145a5b92cf0","modified":1502178480897},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"9069371dcc65eee63081a21e8a56a9f3dbf64c08","modified":1502178480899},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4115c4518cca3f5cf461018aa7a7321138d017cc","modified":1502178480898},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1502178480901},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"948e44c47c3d70584da93e7ce025dede9b7573d7","modified":1502178480906},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1502178481110},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1502178481073},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1502178481110},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1502178481075},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1502178481110},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1502178480907},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1502178481079},{"_id":"themes/yilia/source-src/css/main.scss","hash":"b63c0f9b3bf68efc3bcd7c816bcac6f2fb827528","modified":1502178481087},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1502178481077},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1502178481089},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1502178481090},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1502178481088},{"_id":"themes/yilia/source-src/css/left.scss","hash":"1ee3dd6fa50186af5bedb09d4a0e6b47ddb1b57b","modified":1502178481086},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1502178481091},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"28a01c3d85ec3194095f96988642a16d461f1077","modified":1502178481088},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1502178481091},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1502178481093},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1502178481094},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1502178481092},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"f5bed08765a8f0a344af5d4781ff822a57028148","modified":1502178481094},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1502178481094},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1502178481094},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1502178481094},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1502178481094},{"_id":"themes/yilia/source-src/js/fix.js","hash":"eccdcc7ee79adebf450bc655b2e80eb6801421a6","modified":1502178481094},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1502178481094},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1502178481094},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1502178481094},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1502178481094},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1502178481094},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1502178481094},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1502178481094},{"_id":"themes/yilia/source/main.234bc0.js","hash":"a0359e7962038f53f9ffbd02dcc52485f8e04da8","modified":1502178481110},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1502178480879},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1502178480880},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1502178480881},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1502178480883},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1502178480884},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"501c73f1334d5593bd386e2d15a0024ad259eeaa","modified":1502178480880},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1502178480882},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1502178480902},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1502178480903},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1502178480904},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1502178480905},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1502178480905},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1502178481053},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1502178481082},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1502178481053},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502178481085},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1502178481069},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1502178481071},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502178481084}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"使用代理解决跨域限制","date":"2017-10-06T13:00:53.000Z","_content":"# 问题\n1. 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n# 代理\n1.\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n\n\n2.\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n\n3.\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n","source":"_posts/使用代理解决跨域限制.md","raw":"---\ntitle: 使用代理解决跨域限制\ndate: 2017-10-06 21:00:53\ntags:\n    -跨域\n    -代理\n---\n# 问题\n1. 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n# 代理\n1.\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n\n\n2.\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n\n3.\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n","slug":"使用代理解决跨域限制","published":1,"updated":"2017-10-06T13:57:41.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8gx2sos0000nkw3gi239ehm","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</li>\n</ol>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>1.<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.</p>\n<p>2.<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3.<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</li>\n</ol>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>1.<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.</p>\n<p>2.<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3.<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>"},{"title":"jsonp使用及promise封装","date":"2017-10-05T03:38:12.000Z","_content":"\n1.\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2.\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n\n\n","source":"_posts/jsonp使用及promise封装.md","raw":"---\ntitle: jsonp使用及promise封装\ndate: 2017-10-05 11:38:12\ntags:\n    -跨域\n    -jsonp\n    -promise\n    -异步同步\n---\n\n1.\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2.\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n\n\n","slug":"jsonp使用及promise封装","published":1,"updated":"2017-10-05T07:52:53.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8gx2sox0001nkw38fy8h4rj","content":"<p>1.<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"external\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2.</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre><a id=\"more\"></a>\n<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>1.<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"external\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2.</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre>","more":"<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>"},{"title":"hexo+github+AppVeyor实现不同电脑写博客","date":"2017-04-06T09:32:14.000Z","_content":"## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n","source":"_posts/hexo-github-AppVeyor实现不同电脑写博客.md","raw":"---\ntitle: hexo+github+AppVeyor实现不同电脑写博客\ndate: 2017-04-06 17:32:14\ntags: \n    -hexo\n    -AppVeyor\n    -持续集成\n---\n## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n","slug":"hexo-github-AppVeyor实现不同电脑写博客","published":1,"updated":"2017-08-08T07:48:00.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8gx2sp30003nkw315k65nk4","content":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"external\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"external\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol>\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"external\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">clone_depth: 5</div><div class=\"line\">environment:</div><div class=\"line\">  access_token:</div><div class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</div><div class=\"line\">install:</div><div class=\"line\">  - node --version</div><div class=\"line\">  - npm --version</div><div class=\"line\">  - npm install</div><div class=\"line\">  - npm install hexo-cli -g</div><div class=\"line\">build_script:</div><div class=\"line\">  - hexo generate</div><div class=\"line\">artifacts:</div><div class=\"line\">  - path: public</div><div class=\"line\">  on_success:</div><div class=\"line\">  - git config --global credential.helper store</div><div class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</div><div class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</div><div class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</div><div class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</div><div class=\"line\">  - cd %TEMP%\\static-site</div><div class=\"line\">  - del * /f /q</div><div class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</div><div class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</div><div class=\"line\">  - git add -A</div><div class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"external\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"external\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"external\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"external\">.git解决2</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"external\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"external\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.","more":"</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol>\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"external\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">clone_depth: 5</div><div class=\"line\">environment:</div><div class=\"line\">  access_token:</div><div class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</div><div class=\"line\">install:</div><div class=\"line\">  - node --version</div><div class=\"line\">  - npm --version</div><div class=\"line\">  - npm install</div><div class=\"line\">  - npm install hexo-cli -g</div><div class=\"line\">build_script:</div><div class=\"line\">  - hexo generate</div><div class=\"line\">artifacts:</div><div class=\"line\">  - path: public</div><div class=\"line\">  on_success:</div><div class=\"line\">  - git config --global credential.helper store</div><div class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</div><div class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</div><div class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</div><div class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</div><div class=\"line\">  - cd %TEMP%\\static-site</div><div class=\"line\">  - del * /f /q</div><div class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</div><div class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</div><div class=\"line\">  - git add -A</div><div class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"external\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"external\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"external\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"external\">.git解决2</a></p>"},{"title":"webpack总结(一)","date":"2017-10-07T04:24:53.000Z","_content":"# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","source":"_posts/webpack总结-一.md","raw":"---\ntitle: webpack总结(一)\ndate: 2017-10-07 12:24:53\ntags:\n    -webpack\n---\n# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","slug":"webpack总结-一","published":1,"updated":"2017-10-07T08:20:25.289Z","_id":"cj8gx2sp50004nkw32l525dbq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br><a id=\"more\"></a></p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br>","more":"</p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>"},{"title":"swiper-animate 冲突解决","date":"2017-04-23T03:39:44.000Z","_content":"# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","source":"_posts/swiper-animal-冲突解决.md","raw":"---\ntitle: swiper-animate 冲突解决\ndate: 2017-04-23 11:39:44\ntags: -swiper-animate\n---\n# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","slug":"swiper-animal-冲突解决","published":1,"updated":"2017-08-08T07:48:00.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8gx2sp70005nkw3ts2f0rqo","content":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>\n<a id=\"more\"></a>\n<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>","more":"<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8gx2sos0000nkw3gi239ehm","tag_id":"cj8gx2sp00002nkw3v4fum7yb","_id":"cj8gx2spa0007nkw3kvunhutp"},{"post_id":"cj8gx2sox0001nkw38fy8h4rj","tag_id":"cj8gx2sp80006nkw34j3a6jys","_id":"cj8gx2spc0009nkw3p89nho3y"},{"post_id":"cj8gx2sp30003nkw315k65nk4","tag_id":"cj8gx2spc0008nkw36zjn77ar","_id":"cj8gx2spd000bnkw3xjjz9pya"},{"post_id":"cj8gx2sp50004nkw32l525dbq","tag_id":"cj8gx2spd000ankw3hzc1rydl","_id":"cj8gx2spd000dnkw3k14zyx4i"},{"post_id":"cj8gx2sp70005nkw3ts2f0rqo","tag_id":"cj8gx2spd000cnkw3tnqpjdu7","_id":"cj8gx2spe000enkw3wd8twn7h"}],"Tag":[{"name":"-跨域 -代理","_id":"cj8gx2sp00002nkw3v4fum7yb"},{"name":"-跨域 -jsonp -promise -异步同步","_id":"cj8gx2sp80006nkw34j3a6jys"},{"name":"-hexo -AppVeyor -持续集成","_id":"cj8gx2spc0008nkw36zjn77ar"},{"name":"-webpack","_id":"cj8gx2spd000ankw3hzc1rydl"},{"name":"-swiper-animate","_id":"cj8gx2spd000cnkw3tnqpjdu7"}]}}