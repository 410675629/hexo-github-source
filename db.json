{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/GNAME","path":"GNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/GNAME","hash":"e4a86643263969cda8fea06a8ce5a80f2a727c71","modified":1502183547684},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1502178480853},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1502178480852},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1502178480854},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1502178480856},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1502178480855},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1502178480854},{"_id":"themes/yilia/_config.yml","hash":"e16a786cb9245957f5b466c0579aadfab021ba5b","modified":1507908631437},{"_id":"themes/yilia/webpack.config.js","hash":"14fe482547b12b15bc78cb981c42a4ca5b6ba770","modified":1502178481110},{"_id":"themes/yilia/package.json","hash":"4631f9013f0b1c5fc5d73af4c3624375bfe4d109","modified":1502178480893},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1502178480857},{"_id":"source/_posts/hexo-github-AppVeyor实现不同电脑写博客.md","hash":"d9e1336684e9ba50d87a117012c90bd8f74a9be1","modified":1502178480467},{"_id":"source/_posts/swiper-animal-冲突解决.md","hash":"4c2929d820a4aae4cfc90810a4d0804f9e780d32","modified":1502178480468},{"_id":"source/_posts/jsonp使用及promise封装.md","hash":"ba1ac77adad7144aa3acff8f6d283f154e9ba793","modified":1507189973367},{"_id":"source/_posts/vue-cli-2中webpack的配置分析二.md","hash":"ffd559a39a3320014e0608cb17f67c0e6e66d7ea","modified":1507445365482},{"_id":"source/_posts/vue-cli-2-中webpack的配置-一.md","hash":"48d3b330ea8df345970376c312acf70eba696891","modified":1507390146263},{"_id":"source/_posts/vue-cli中process-env-NODE-ENV.md","hash":"024be98ec2de91937d49e082387292bc3a6417f9","modified":1507458871664},{"_id":"source/_posts/vue-cli编译打包后起node服务测试.md","hash":"4c3bdffef1f807618c68081870cb3d0aa18b3372","modified":1507446983020},{"_id":"source/_posts/webpack总结-一.md","hash":"2acdbce303c5b2209a20b4ca47a6a4b2622d7cfe","modified":1507364425289},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1502178480859},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1502178480860},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1502178480861},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1502178480862},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1502178480864},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1502178480865},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1502178480867},{"_id":"source/_posts/使用代理解决跨域限制.md","hash":"c0b3df9dad3d688f38d8754e591746cedff56589","modified":1507298261212},{"_id":"source/_posts/webpack总结二.md","hash":"184c8b2cc2dc267d8740729edfd5d4fb6b6fd3c6","modified":1507369405743},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1502178481110},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1502178480887},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1502178480887},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1502178480888},{"_id":"themes/yilia/source/slider.885efe.js","hash":"850271f829a57f60385a9807195965dcfdf4dfb6","modified":1502197098250},{"_id":"themes/yilia/layout/layout.ejs","hash":"077f40edaab099490dbe9efeba1136dfe4b5f347","modified":1502197080746},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502178480890},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1502178480892},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502178480891},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1502178480894},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1502178481094},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1502178481094},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1502178481110},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1502178481110},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1502178481110},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1502178481110},{"_id":"source/_posts/webpack总结三.md","hash":"513c310c421bb605d0ef1a5eee148c13bb884422","modified":1507384502037},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502178481110},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1502178481110},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1502178481110},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502178481110},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1502178480869},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1502178480870},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1502178480870},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"6c4a76245ca2379cfc649aed3b07f1a7b867e4a7","modified":1502178480872},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1502178480873},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"c5173337832c29499311260be291e6c12a329079","modified":1502178480874},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1502178480875},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"2faa75a163e3233051e62e0f6e2186a502dcaa7a","modified":1507909986165},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1502178480875},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1502178480876},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1502178480877},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1502178480877},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1502178480878},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"538b6d35b25cbdba7dc77feec638336625c8ef8b","modified":1502178480885},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1502178480886},{"_id":"themes/yilia/source/main.234bc0.js","hash":"a0359e7962038f53f9ffbd02dcc52485f8e04da8","modified":1502178481110},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1502178481094},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1502178480884},{"_id":"themes/yilia/source/main.234bc0.css","hash":"0b505e2d152f71ae1c9c201f9a25c28c39d8f6d0","modified":1502197077651},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1502178481094},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1502178481094},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1502178481094},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1502178481094},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1502178481094},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1502178481094},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1502178481094},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1502178480895},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1502178480896},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"8a0ae8ee6af8df3f215f1cd4ecc10145a5b92cf0","modified":1502178480897},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4115c4518cca3f5cf461018aa7a7321138d017cc","modified":1502178480898},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"a664a5b474d15ab42422f38f24d3a9dcfe4c9e0e","modified":1502178480899},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"9069371dcc65eee63081a21e8a56a9f3dbf64c08","modified":1502178480899},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1502178480901},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"948e44c47c3d70584da93e7ce025dede9b7573d7","modified":1502178480906},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1502178480907},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1502178481073},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1502178481075},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1502178481077},{"_id":"themes/yilia/source-src/js/fix.js","hash":"eccdcc7ee79adebf450bc655b2e80eb6801421a6","modified":1502178481094},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1502178481094},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1502178481079},{"_id":"themes/yilia/source-src/css/main.scss","hash":"b63c0f9b3bf68efc3bcd7c816bcac6f2fb827528","modified":1502178481087},{"_id":"themes/yilia/source-src/css/left.scss","hash":"1ee3dd6fa50186af5bedb09d4a0e6b47ddb1b57b","modified":1502178481086},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"28a01c3d85ec3194095f96988642a16d461f1077","modified":1502178481088},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1502178481089},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1502178481088},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1502178481090},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1502178481094},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1502178481092},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1502178481091},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"f5bed08765a8f0a344af5d4781ff822a57028148","modified":1502178481094},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1502178481091},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1502178481094},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1502178481093},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1502178481094},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1502178480879},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1502178480880},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1502178480881},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1502178480883},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1502178480884},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"501c73f1334d5593bd386e2d15a0024ad259eeaa","modified":1502178480880},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1502178480882},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1502178480902},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1502178480904},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1502178480903},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1502178480905},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1502178480905},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1502178481053},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1502178481082},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1502178481053},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1502178481085},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1502178481069},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1502178481071},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1502178481084},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"9201b2e86d697959baa7c923e14dac72d37d37ca","modified":1507909351398}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"swiper-animate 冲突解决","date":"2017-04-23T03:39:44.000Z","_content":"# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","source":"_posts/swiper-animal-冲突解决.md","raw":"---\ntitle: swiper-animate 冲突解决\ndate: 2017-04-23 11:39:44\ntags: -swiper-animate\n---\n# 冲突\n* swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。\n* swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。\n* 这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，\n但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。\n* 在网上也没找到解决办法，最后只能用笨办法了。\n\n<!-- more -->\n\n#解决\n1. 在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(\".ani\")为querySelectorAll(\".anime\")。\n![11](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png)\n2. 在html中把第二个用到动画的标签类名由ani改成animate\n![22](http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png)\n3. 在js中创建实例时候，调用修改过的函数名。\n![33](http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png)\n\n这样就解决了冲突，只是办法太笨了。","slug":"swiper-animal-冲突解决","published":1,"updated":"2017-08-08T07:48:00.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8h00006ww35osy782b","content":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>\n<a id=\"more\"></a>\n<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><ul>\n<li>swiper是个使用广泛，兼容性很高的js插件，可以独立使用，也可以跟jQuery配合使用。</li>\n<li>swiper-animate是swiper基础上开发的动画插件，可以实现非常酷炫的效果。</li>\n<li>这周在写一个页面，里面有轮播图、tab选项卡，用swiper开发非常方便，当然也用到了swiper-animate，<br>但是，两个swiper实例之间的 swiper-animate会互相影响，发生动画效果消失或错乱。</li>\n<li>在网上也没找到解决办法，最后只能用笨办法了。</li>\n</ul>","more":"<p>#解决</p>\n<ol>\n<li>在swiper-animate.jsh中复制三个函数，并分别改名为原名+me，修改querySelectorAll(“.ani”)为querySelectorAll(“.anime”)。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-animate.png\" alt=\"11\"></li>\n<li>在html中把第二个用到动画的标签类名由ani改成animate<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swiper-html.png\" alt=\"22\"></li>\n<li>在js中创建实例时候，调用修改过的函数名。<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo-2swper-function.png\" alt=\"33\"></li>\n</ol>\n<p>这样就解决了冲突，只是办法太笨了。</p>"},{"title":"vue-cli-2中webpack的配置分析二","date":"2017-10-08T02:44:20.000Z","_content":"这片也是转载,[叶家伟的博客](http://www.cnblogs.com/ye-hcj/p/7077796.html),这里有一系列的vue-cli中webpack分析文章,可以移步阅读.\n另外还找到另外一片博客[vue-cli的webpack模板项目配置文件分析](http://blog.csdn.net/hongchh/article/details/55113751)\n加上前面滴滴那篇介绍,对比读起来肯定会理解的快.\n总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.\n## config/index.js\n        \n        // see http://vuejs-templates.github.io/webpack for documentation.\n        // path是node.js的路径模块，用来处理路径统一的问题\n        var path = require('path')\n        \n        module.exports = {\n            // 下面是build也就是生产编译环境下的一些配置\n            build: {\n                // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n                env: require('./prod.env'),\n                // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n                index: path.resolve(__dirname, '../dist/index.html'),\n                // 下面定义的是静态资源的根目录 也就是dist目录\n                assetsRoot: path.resolve(__dirname, '../dist'),\n                // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n                assetsSubDirectory: 'static',\n                // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n                assetsPublicPath: '/',\n                // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n                productionSourceMap: true,\n                // Gzip off by default as many popular static hosts such as\n                // Surge or Netlify already gzip all static assets for you.\n                // Before setting to `true`, make sure to:\n                // npm install --save-dev compression-webpack-plugin\n                // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n                productionGzip: false,\n                // 下面定义要压缩哪些类型的文件\n                productionGzipExtensions: ['js', 'css'],\n                // Run the build command with an extra argument to\n                // View the bundle analyzer report after build finishes:\n                // `npm run build --report`\n                // Set to `true` or `false` to always turn it on or off\n                // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n                // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n                bundleAnalyzerReport: process.env.npm_config_report\n            },\n            dev: {\n                // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n                env: require('./dev.env'),\n                // 下面是dev-server的端口号，可以自行更改\n                port: 8080,\n                // 下面表示是否自定代开浏览器\n                autoOpenBrowser: true,\n                assetsSubDirectory: 'static',\n                assetsPublicPath: '/',\n                // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n                // 详见(3)\n                proxyTable: {},\n                // CSS Sourcemaps off by default because relative paths are \"buggy\"\n                // with this option, according to the CSS-Loader README\n                // (https://github.com/webpack/css-loader#sourcemaps)\n                // In our experience, they generally work as expected,\n                // just be aware of this issue when enabling this option.\n                // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n                // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n                cssSourceMap: false\n            }\n        }\n<!-- more -->        \n## prod.env.js \n        \n         module.exports = {\n                // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n                NODE_ENV: '\"production\"'\n            }\n\n## dev.env.js\n        \n         // 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n            var merge = require('webpack-merge')\n            // 导入prod.env.js配置文件\n            var prodEnv = require('./prod.env')\n            // 将两个配置对象合并，最终结果是 NODE_ENV: '\"development\"'\n            module.exports = merge(prodEnv, {\n                NODE_ENV: '\"development\"'\n            })\n            \n## proxyTable用法\n           \n           vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n               proxyTable: {\n                   '/list': {\n                       target: 'http://api.xxxxxxxx.com', -> 目标url地址\n                       changeOrigin: true, -> 指示是否跨域\n                       pathRewrite: {\n                       '^/list': '/list' -> 可以使用 /list 等价于 api.xxxxxxxx.com/list\n                       }\n                   }\n               }\n            \n            ","source":"_posts/vue-cli-2中webpack的配置分析二.md","raw":"---\ntitle: vue-cli-2中webpack的配置分析二\ndate: 2017-10-08 10:44:20\ntags:\n    - vue-cli\n    - webpack\n---\n这片也是转载,[叶家伟的博客](http://www.cnblogs.com/ye-hcj/p/7077796.html),这里有一系列的vue-cli中webpack分析文章,可以移步阅读.\n另外还找到另外一片博客[vue-cli的webpack模板项目配置文件分析](http://blog.csdn.net/hongchh/article/details/55113751)\n加上前面滴滴那篇介绍,对比读起来肯定会理解的快.\n总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.\n## config/index.js\n        \n        // see http://vuejs-templates.github.io/webpack for documentation.\n        // path是node.js的路径模块，用来处理路径统一的问题\n        var path = require('path')\n        \n        module.exports = {\n            // 下面是build也就是生产编译环境下的一些配置\n            build: {\n                // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n                env: require('./prod.env'),\n                // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n                index: path.resolve(__dirname, '../dist/index.html'),\n                // 下面定义的是静态资源的根目录 也就是dist目录\n                assetsRoot: path.resolve(__dirname, '../dist'),\n                // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n                assetsSubDirectory: 'static',\n                // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n                assetsPublicPath: '/',\n                // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n                productionSourceMap: true,\n                // Gzip off by default as many popular static hosts such as\n                // Surge or Netlify already gzip all static assets for you.\n                // Before setting to `true`, make sure to:\n                // npm install --save-dev compression-webpack-plugin\n                // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n                productionGzip: false,\n                // 下面定义要压缩哪些类型的文件\n                productionGzipExtensions: ['js', 'css'],\n                // Run the build command with an extra argument to\n                // View the bundle analyzer report after build finishes:\n                // `npm run build --report`\n                // Set to `true` or `false` to always turn it on or off\n                // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n                // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n                bundleAnalyzerReport: process.env.npm_config_report\n            },\n            dev: {\n                // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n                env: require('./dev.env'),\n                // 下面是dev-server的端口号，可以自行更改\n                port: 8080,\n                // 下面表示是否自定代开浏览器\n                autoOpenBrowser: true,\n                assetsSubDirectory: 'static',\n                assetsPublicPath: '/',\n                // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n                // 详见(3)\n                proxyTable: {},\n                // CSS Sourcemaps off by default because relative paths are \"buggy\"\n                // with this option, according to the CSS-Loader README\n                // (https://github.com/webpack/css-loader#sourcemaps)\n                // In our experience, they generally work as expected,\n                // just be aware of this issue when enabling this option.\n                // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n                // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n                cssSourceMap: false\n            }\n        }\n<!-- more -->        \n## prod.env.js \n        \n         module.exports = {\n                // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n                NODE_ENV: '\"production\"'\n            }\n\n## dev.env.js\n        \n         // 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n            var merge = require('webpack-merge')\n            // 导入prod.env.js配置文件\n            var prodEnv = require('./prod.env')\n            // 将两个配置对象合并，最终结果是 NODE_ENV: '\"development\"'\n            module.exports = merge(prodEnv, {\n                NODE_ENV: '\"development\"'\n            })\n            \n## proxyTable用法\n           \n           vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n               proxyTable: {\n                   '/list': {\n                       target: 'http://api.xxxxxxxx.com', -> 目标url地址\n                       changeOrigin: true, -> 指示是否跨域\n                       pathRewrite: {\n                       '^/list': '/list' -> 可以使用 /list 等价于 api.xxxxxxxx.com/list\n                       }\n                   }\n               }\n            \n            ","slug":"vue-cli-2中webpack的配置分析二","published":1,"updated":"2017-10-08T06:49:25.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8h00016ww3upfnpyj3","content":"<p>这片也是转载,<a href=\"http://www.cnblogs.com/ye-hcj/p/7077796.html\" target=\"_blank\" rel=\"external\">叶家伟的博客</a>,这里有一系列的vue-cli中webpack分析文章,可以移步阅读.<br>另外还找到另外一片博客<a href=\"http://blog.csdn.net/hongchh/article/details/55113751\" target=\"_blank\" rel=\"external\">vue-cli的webpack模板项目配置文件分析</a><br>加上前面滴滴那篇介绍,对比读起来肯定会理解的快.<br>总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.</p>\n<h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// path是node.js的路径模块，用来处理路径统一的问题\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n    // 下面是build也就是生产编译环境下的一些配置\n    build: {\n        // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n        env: require(&apos;./prod.env&apos;),\n        // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n        index: path.resolve(__dirname, &apos;../dist/index.html&apos;),\n        // 下面定义的是静态资源的根目录 也就是dist目录\n        assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),\n        // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n        assetsSubDirectory: &apos;static&apos;,\n        // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n        assetsPublicPath: &apos;/&apos;,\n        // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n        productionSourceMap: true,\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n        productionGzip: false,\n        // 下面定义要压缩哪些类型的文件\n        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n        // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n        bundleAnalyzerReport: process.env.npm_config_report\n    },\n    dev: {\n        // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n        env: require(&apos;./dev.env&apos;),\n        // 下面是dev-server的端口号，可以自行更改\n        port: 8080,\n        // 下面表示是否自定代开浏览器\n        autoOpenBrowser: true,\n        assetsSubDirectory: &apos;static&apos;,\n        assetsPublicPath: &apos;/&apos;,\n        // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n        // 详见(3)\n        proxyTable: {},\n        // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n        // with this option, according to the CSS-Loader README\n        // (https://github.com/webpack/css-loader#sourcemaps)\n        // In our experience, they generally work as expected,\n        // just be aware of this issue when enabling this option.\n        // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n        // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n        cssSourceMap: false\n    }\n}\n</code></pre><a id=\"more\"></a>        \n<h2 id=\"prod-env-js\"><a href=\"#prod-env-js\" class=\"headerlink\" title=\"prod.env.js\"></a>prod.env.js</h2><pre><code>module.exports = {\n       // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n       NODE_ENV: &apos;&quot;production&quot;&apos;\n   }\n</code></pre><h2 id=\"dev-env-js\"><a href=\"#dev-env-js\" class=\"headerlink\" title=\"dev.env.js\"></a>dev.env.js</h2><pre><code>// 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n   var merge = require(&apos;webpack-merge&apos;)\n   // 导入prod.env.js配置文件\n   var prodEnv = require(&apos;./prod.env&apos;)\n   // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos;\n   module.exports = merge(prodEnv, {\n       NODE_ENV: &apos;&quot;development&quot;&apos;\n   })\n</code></pre><h2 id=\"proxyTable用法\"><a href=\"#proxyTable用法\" class=\"headerlink\" title=\"proxyTable用法\"></a>proxyTable用法</h2><pre><code>vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n    proxyTable: {\n        &apos;/list&apos;: {\n            target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址\n            changeOrigin: true, -&gt; 指示是否跨域\n            pathRewrite: {\n            &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list\n            }\n        }\n    }\n</code></pre>","site":{"data":{}},"excerpt":"<p>这片也是转载,<a href=\"http://www.cnblogs.com/ye-hcj/p/7077796.html\" target=\"_blank\" rel=\"external\">叶家伟的博客</a>,这里有一系列的vue-cli中webpack分析文章,可以移步阅读.<br>另外还找到另外一片博客<a href=\"http://blog.csdn.net/hongchh/article/details/55113751\" target=\"_blank\" rel=\"external\">vue-cli的webpack模板项目配置文件分析</a><br>加上前面滴滴那篇介绍,对比读起来肯定会理解的快.<br>总之,网上有已有大量的学习资料,前人栽树,后人乘凉,感谢.</p>\n<h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// path是node.js的路径模块，用来处理路径统一的问题\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n    // 下面是build也就是生产编译环境下的一些配置\n    build: {\n        // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1)\n        env: require(&apos;./prod.env&apos;),\n        // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html\n        index: path.resolve(__dirname, &apos;../dist/index.html&apos;),\n        // 下面定义的是静态资源的根目录 也就是dist目录\n        assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),\n        // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n        assetsSubDirectory: &apos;static&apos;,\n        // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n        assetsPublicPath: &apos;/&apos;,\n        // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n        productionSourceMap: true,\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n        productionGzip: false,\n        // 下面定义要压缩哪些类型的文件\n        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭\n        // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n        bundleAnalyzerReport: process.env.npm_config_report\n    },\n    dev: {\n        // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2)\n        env: require(&apos;./dev.env&apos;),\n        // 下面是dev-server的端口号，可以自行更改\n        port: 8080,\n        // 下面表示是否自定代开浏览器\n        autoOpenBrowser: true,\n        assetsSubDirectory: &apos;static&apos;,\n        assetsPublicPath: &apos;/&apos;,\n        // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n        // 详见(3)\n        proxyTable: {},\n        // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n        // with this option, according to the CSS-Loader README\n        // (https://github.com/webpack/css-loader#sourcemaps)\n        // In our experience, they generally work as expected,\n        // just be aware of this issue when enabling this option.\n        // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用\n        // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了\n        cssSourceMap: false\n    }\n}\n</code></pre>","more":"<h2 id=\"prod-env-js\"><a href=\"#prod-env-js\" class=\"headerlink\" title=\"prod.env.js\"></a>prod.env.js</h2><pre><code>module.exports = {\n       // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境\n       NODE_ENV: &apos;&quot;production&quot;&apos;\n   }\n</code></pre><h2 id=\"dev-env-js\"><a href=\"#dev-env-js\" class=\"headerlink\" title=\"dev.env.js\"></a>dev.env.js</h2><pre><code>// 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧\n   var merge = require(&apos;webpack-merge&apos;)\n   // 导入prod.env.js配置文件\n   var prodEnv = require(&apos;./prod.env&apos;)\n   // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos;\n   module.exports = merge(prodEnv, {\n       NODE_ENV: &apos;&quot;development&quot;&apos;\n   })\n</code></pre><h2 id=\"proxyTable用法\"><a href=\"#proxyTable用法\" class=\"headerlink\" title=\"proxyTable用法\"></a>proxyTable用法</h2><pre><code>vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api\n    proxyTable: {\n        &apos;/list&apos;: {\n            target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址\n            changeOrigin: true, -&gt; 指示是否跨域\n            pathRewrite: {\n            &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list\n            }\n        }\n    }\n</code></pre>"},{"title":"hexo+github+AppVeyor实现不同电脑写博客","date":"2017-04-06T09:32:14.000Z","_content":"## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n","source":"_posts/hexo-github-AppVeyor实现不同电脑写博客.md","raw":"---\ntitle: hexo+github+AppVeyor实现不同电脑写博客\ndate: 2017-04-06 17:32:14\ntags: \n    -hexo\n    -AppVeyor\n    -持续集成\n---\n## hexo + github 部分\n+ 以前一直用的像[博客园](http://www.cnblogs.com/)这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.\n+ 如何使用,网上已有好多教程,不再赘言.\n+ 美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.\n+ 网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.\n+ 我是学习这篇教程做的,[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/),以下也是我根据其做的实践.\n<!-- more -->\n\n## AppVeyor持续集成\n我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.\n\n1. 新建两个github仓库,一个是 [killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)(以我的为例) ,另一个是便是备份源文件的仓库 [hexo-github-source](https://github.com/killerlei/hexo-github-source)(以我的为例).\n\n\n2. 注册[APPVeyor](https://www.appveyor.com/),支持github登录,然后新建项目,直接选择github里面的源文件仓库[hexo-github-source](https://github.com/killerlei/hexo-github-source) \n![](http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png)\n\n3. 在该项目的settings中设置Envirommemt\n![](http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png)\n\n4. 在源文件根目录中添加appveyor.yml配置文件,我的如下 \n```\nclone_depth: 5\nenvironment:\n  access_token:\n    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)\ninstall:\n  - node --version\n  - npm --version\n  - npm install\n  - npm install hexo-cli -g\nbuild_script:\n  - hexo generate\nartifacts:\n  - path: public\n  on_success:\n  - git config --global credential.helper store\n  - ps: Add-Content \"$env:USERPROFILE\\.git-credentials\" \"https://$($env:access_token):x-oauth-basic@github.com`n\"\n  - git config --global user.email \"%GIT_USER_EMAIL%\"\n  - git config --global user.name \"%GIT_USER_NAME%\"\n  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site\n  - cd %TEMP%\\static-site\n  - del * /f /q\n  - for /d %%p IN (*) do rmdir \"%%p\" /s /q\n  - SETLOCAL EnableDelayedExpansion & robocopy \"%APPVEYOR_BUILD_FOLDER%\\public\" \"%TEMP%\\static-site\" /e & IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))\n  - git add -A\n  - if \"%APPVEYOR_REPO_BRANCH%\"==\"master\" if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m \"Update Static Site\" && git push origin %TARGET_BRANCH% && appveyor AddMessage \"Static Site Updated\")\n```\n5. 第4步需要个人的secure,先到github新建 [Personal access tokens](https://github.com/settings/tokens),然后到AppVeyor加密[AppVeyor加密](https://ci.appveyor.com/tools/encrypt),然后写到第4步里\n\n6. 现在就可以在本地写文章了,比如 <br>新建一篇文章  \n>hexo new \"hexo使用总结\"<br> \n  hexo s   (在本地浏览器检查正常)<br>\n  git push origin master (推送到源文件备份仓库)<br>\n\n   现在AppVeor就开始自动构建.\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png)\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png) \n\n成功后就会把生成的文件推送到[killerlei.github.io.](https://github.com/killerlei/killerlei.github.io)仓库\n\n![](http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png)    \n\n就可以在[killerlei.github.io.](https://killerlei.github.io./)访问到新建的文章.\n\n\n####  这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\nps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br>\n向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看[.git解决1](http://memory.blog.51cto.com/6054201/1217107)和[.git解决2](http://bbs.csdn.net/topics/390822726)\n","slug":"hexo-github-AppVeyor实现不同电脑写博客","published":1,"updated":"2017-08-08T07:48:00.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8w00036ww37rhjitco","content":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"external\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"external\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.<a id=\"more\"></a>\n</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol>\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"external\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">clone_depth: 5</div><div class=\"line\">environment:</div><div class=\"line\">  access_token:</div><div class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</div><div class=\"line\">install:</div><div class=\"line\">  - node --version</div><div class=\"line\">  - npm --version</div><div class=\"line\">  - npm install</div><div class=\"line\">  - npm install hexo-cli -g</div><div class=\"line\">build_script:</div><div class=\"line\">  - hexo generate</div><div class=\"line\">artifacts:</div><div class=\"line\">  - path: public</div><div class=\"line\">  on_success:</div><div class=\"line\">  - git config --global credential.helper store</div><div class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</div><div class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</div><div class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</div><div class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</div><div class=\"line\">  - cd %TEMP%\\static-site</div><div class=\"line\">  - del * /f /q</div><div class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</div><div class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</div><div class=\"line\">  - git add -A</div><div class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"external\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"external\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"external\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"external\">.git解决2</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"hexo-github-部分\"><a href=\"#hexo-github-部分\" class=\"headerlink\" title=\"hexo + github 部分\"></a>hexo + github 部分</h2><ul>\n<li>以前一直用的像<a href=\"http://www.cnblogs.com/\" target=\"_blank\" rel=\"external\">博客园</a>这样专业的博客网站,但是一直想有个个人站点,正好github提供这样的类似功能,并且发现hexo这样的好工具.hexo使用markdown写文章,并且支持github部署.这就很完美了.</li>\n<li>如何使用,网上已有好多教程,不再赘言.</li>\n<li>美中不足的是:换了电脑或者电脑坏了,源文件丢失,就得重新写,非常的麻烦.</li>\n<li>网上也有很多解决方式,我比较喜欢在github备份源文件,并且使用AppVeyor实现自动部署,不用在本地产生文件,也不用即备份又要部署那么繁琐.</li>\n<li>我是学习这篇教程做的,<a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"external\">Hexo的版本控制与持续集成</a>,以下也是我根据其做的实践.","more":"</li>\n</ul>\n<h2 id=\"AppVeyor持续集成\"><a href=\"#AppVeyor持续集成\" class=\"headerlink\" title=\"AppVeyor持续集成\"></a>AppVeyor持续集成</h2><p>我是在今年被问到CI,才知道持续集成这个东东的.也没有有机会实践,所以只能跟着教程一步一步操作.</p>\n<ol>\n<li>新建两个github仓库,一个是 <a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>(以我的为例) ,另一个是便是备份源文件的仓库 <a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a>(以我的为例).</li>\n</ol>\n<ol>\n<li><p>注册<a href=\"https://www.appveyor.com/\" target=\"_blank\" rel=\"external\">APPVeyor</a>,支持github登录,然后新建项目,直接选择github里面的源文件仓库<a href=\"https://github.com/killerlei/hexo-github-source\" target=\"_blank\" rel=\"external\">hexo-github-source</a><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/imagesappveyor-p.png\" alt=\"\"></p>\n</li>\n<li><p>在该项目的settings中设置Envirommemt<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/Appveyor-e.png\" alt=\"\"></p>\n</li>\n<li><p>在源文件根目录中添加appveyor.yml配置文件,我的如下 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">clone_depth: 5</div><div class=\"line\">environment:</div><div class=\"line\">  access_token:</div><div class=\"line\">    secure: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(这里需要自己的)</div><div class=\"line\">install:</div><div class=\"line\">  - node --version</div><div class=\"line\">  - npm --version</div><div class=\"line\">  - npm install</div><div class=\"line\">  - npm install hexo-cli -g</div><div class=\"line\">build_script:</div><div class=\"line\">  - hexo generate</div><div class=\"line\">artifacts:</div><div class=\"line\">  - path: public</div><div class=\"line\">  on_success:</div><div class=\"line\">  - git config --global credential.helper store</div><div class=\"line\">  - ps: Add-Content &quot;$env:USERPROFILE\\.git-credentials&quot; &quot;https://$($env:access_token):x-oauth-basic@github.com`n&quot;</div><div class=\"line\">  - git config --global user.email &quot;%GIT_USER_EMAIL%&quot;</div><div class=\"line\">  - git config --global user.name &quot;%GIT_USER_NAME%&quot;</div><div class=\"line\">  - git clone --depth 5 -q --branch=%TARGET_BRANCH% %STATIC_SITE_REPO% %TEMP%\\static-site</div><div class=\"line\">  - cd %TEMP%\\static-site</div><div class=\"line\">  - del * /f /q</div><div class=\"line\">  - for /d %%p IN (*) do rmdir &quot;%%p&quot; /s /q</div><div class=\"line\">  - SETLOCAL EnableDelayedExpansion &amp; robocopy &quot;%APPVEYOR_BUILD_FOLDER%\\public&quot; &quot;%TEMP%\\static-site&quot; /e &amp; IF !ERRORLEVEL! EQU 1 (exit 0) ELSE (IF !ERRORLEVEL! EQU 3 (exit 0) ELSE (exit 1))</div><div class=\"line\">  - git add -A</div><div class=\"line\">  - if &quot;%APPVEYOR_REPO_BRANCH%&quot;==&quot;master&quot; if not defined APPVEYOR_PULL_REQUEST_NUMBER (git diff --quiet --exit-code --cached || git commit -m &quot;Update Static Site&quot; &amp;&amp; git push origin %TARGET_BRANCH% &amp;&amp; appveyor AddMessage &quot;Static Site Updated&quot;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>第4步需要个人的secure,先到github新建 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"external\">Personal access tokens</a>,然后到AppVeyor加密<a href=\"https://ci.appveyor.com/tools/encrypt\" target=\"_blank\" rel=\"external\">AppVeyor加密</a>,然后写到第4步里</p>\n</li>\n<li><p>现在就可以在本地写文章了,比如 <br>新建一篇文章  </p>\n<blockquote>\n<p>hexo new “hexo使用总结”<br><br>hexo s   (在本地浏览器检查正常)<br><br>git push origin master (推送到源文件备份仓库)<br></p>\n</blockquote>\n<p>现在AppVeor就开始自动构建.<br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b1.png\" alt=\"\"><br><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/appveyor-b2.png\" alt=\"\"> </p>\n</li>\n</ol>\n<p>成功后就会把生成的文件推送到<a href=\"https://github.com/killerlei/killerlei.github.io\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>仓库</p>\n<p><img src=\"http://oo0zdjapt.bkt.clouddn.com/hexo/images/git-io.png\" alt=\"\">    </p>\n<p>就可以在<a href=\"https://killerlei.github.io./\" target=\"_blank\" rel=\"external\">killerlei.github.io.</a>访问到新建的文章.</p>\n<h4 id=\"这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\"><a href=\"#这样是不是很方便-换个电脑直接从源文件仓库clone下来-也不怕丢失\" class=\"headerlink\" title=\"这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.\"></a>这样是不是很方便,换个电脑直接从源文件仓库clone下来,也不怕丢失.</h4><p>ps:如果使用了hexo的非默认主题,可能会遇到这样的情况(比如我用的yilia主题):<br><br>向源文件仓库push时,会失败,我在网上查了以下,好像是主题文件含有.git文件,本来受git控制,所以会冲突.需要删除.git. 我弄了好久才糊里糊涂弄好.如需帮助,请看<a href=\"http://memory.blog.51cto.com/6054201/1217107\" target=\"_blank\" rel=\"external\">.git解决1</a>和<a href=\"http://bbs.csdn.net/topics/390822726\" target=\"_blank\" rel=\"external\">.git解决2</a></p>"},{"title":"jsonp使用及promise封装","date":"2017-10-05T03:38:12.000Z","_content":"\n1.\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2.\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n\n\n","source":"_posts/jsonp使用及promise封装.md","raw":"---\ntitle: jsonp使用及promise封装\ndate: 2017-10-05 11:38:12\ntags:\n    -跨域\n    -jsonp\n    -promise\n    -异步同步\n---\n\n1.\n[jsonp](https://github.com/webmodules/jsonp)简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.\n\n2.\n\n        jsonp(url, opts, fn)\n\n        url (String) url to fetch\n        opts (Object), optional\n            param (String) name of the query string parameter to specify the callback (defaults to callback)\n            timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n            prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n            name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n        fn callback\n            The callback is called with err, data parameters.\n\n        If it times out, the err will be an Error object whose message is Timeout.\n\n        Returns a function that, when called, will cancel the in-progress jsonp request (fn won't be called).\n\n    opts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n<!-- more -->\n\n3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.\n    举例来讲\n\n    //构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n        var promise = new Promise(function(resolve,reject){\n                异步操作代码......\n                resolve(value)\n                reject(error)\n        }\n        promise.then(function(value){......},function(err){....})\n\n\n4.利用promise改造jsonp\n\n    import originJSONP from 'jsonp'\n    export default function jsonp(url, data, option) {\n      url += (url.indexOf('?') < 0 ? '?' : '&') + param(data)\n      return new Promise((resolve, reject) => {\n        originJSONP(url, option, (err, data) => {\n          if (!err) {\n            resolve(data)\n          } else {\n            reject(err)\n          }\n        })\n      })\n    }\n    function param(data) {\n      let url = ''\n      for (var k in data) {\n        let value = data[k] !== undefined ? data[k] : ''\n        url += `&${k}=${encodeURIComponent(value)}`\n      }\n      return url ? url.substring(1) : ''\n    }\n\n\n5.使用(在vue中使用)\n\n    import jsonp from './xxxxx'\n\n    data(){\n        return {\n            data:''\n        }\n    },\n    methods:{\n        getData(){\n            let url='**********'\n            let data = {xxxxxxx:xxxxx}\n            let option = {xxxxx:xxxxx}\n            jsonp(url,data,option).then((res) => {\n                 if (res.code === 0) {\n                    this.data = res.data.list\n                 }\n            })\n        }\n    }\n\n\n","slug":"jsonp使用及promise封装","published":1,"updated":"2017-10-05T07:52:53.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8w00046ww3lertgpfh","content":"<p>1.<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"external\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2.</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre><a id=\"more\"></a>\n<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>1.<br><a href=\"https://github.com/webmodules/jsonp\" target=\"_blank\" rel=\"external\">jsonp</a>简单封装了跨域请求方法jsonp,利用script标签不受同源策略的限制,达到ajax的效果.</p>\n<p>2.</p>\n<pre><code>    jsonp(url, opts, fn)\n\n    url (String) url to fetch\n    opts (Object), optional\n        param (String) name of the query string parameter to specify the callback (defaults to callback)\n        timeout (Number) how long after a timeout error is emitted. 0 to disable (defaults to 60000)\n        prefix (String) prefix for the global callback functions that handle jsonp responses (defaults to __jp)\n        name (String) name of the global callback functions that handle jsonp responses (defaults to prefix + incremented counter)\n    fn callback\n        The callback is called with err, data parameters.\n\n    If it times out, the err will be an Error object whose message is Timeout.\n\n    Returns a function that, when called, will cancel the in-progress jsonp request (fn won&apos;t be called).\n\nopts 中里面属性都有默认值,可以不用设置,但是注意param是前后端协议好的请求字段,默认值为callback,后端要根据这个字段拿到函数名,也就是另一个属性name,即jsonp原理中js中已经定义好的函数(jsonp内部会分配给全局对象对应属性,有name则是name值,如果没有则会根据prefix自动分配,并赋值fn).\n</code></pre>","more":"<p>3.这种用回调函数异步编程的方式可以利用ES6的promise实现同步编程,更加直观.<br>    举例来讲</p>\n<pre><code>//构造函数接受两个参数,分别代表已完成/未完成两种状态变化,返回一各实例,可以在其then方法里传入成功时处理函数和失败时处理函数\n\n    var promise = new Promise(function(resolve,reject){\n            异步操作代码......\n            resolve(value)\n            reject(error)\n    }\n    promise.then(function(value){......},function(err){....})\n</code></pre><p>4.利用promise改造jsonp</p>\n<pre><code>import originJSONP from &apos;jsonp&apos;\nexport default function jsonp(url, data, option) {\n  url += (url.indexOf(&apos;?&apos;) &lt; 0 ? &apos;?&apos; : &apos;&amp;&apos;) + param(data)\n  return new Promise((resolve, reject) =&gt; {\n    originJSONP(url, option, (err, data) =&gt; {\n      if (!err) {\n        resolve(data)\n      } else {\n        reject(err)\n      }\n    })\n  })\n}\nfunction param(data) {\n  let url = &apos;&apos;\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : &apos;&apos;\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : &apos;&apos;\n}\n</code></pre><p>5.使用(在vue中使用)</p>\n<pre><code>import jsonp from &apos;./xxxxx&apos;\n\ndata(){\n    return {\n        data:&apos;&apos;\n    }\n},\nmethods:{\n    getData(){\n        let url=&apos;**********&apos;\n        let data = {xxxxxxx:xxxxx}\n        let option = {xxxxx:xxxxx}\n        jsonp(url,data,option).then((res) =&gt; {\n             if (res.code === 0) {\n                this.data = res.data.list\n             }\n        })\n    }\n}\n</code></pre>"},{"title":"vue-cli(#2)中webpack的配置(一)","date":"2017-10-07T14:39:39.000Z","_content":"这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.\n\n## 目录结构\n\n    .\n    ├── README.md\n    ├── build\n    │   ├── build.js\n    │   ├── check-versions.js\n    │   ├── dev-client.js\n    │   ├── dev-server.js\n    │   ├── utils.js\n    │   ├── webpack.base.conf.js\n    │   ├── webpack.dev.conf.js\n    │   └── webpack.prod.conf.js\n    ├── config\n    │   ├── dev.env.js\n    │   ├── index.js\n    │   └── prod.env.js\n    ├── index.html\n    ├── package.json\n    ├── src\n    │   ├── App.vue\n    │   ├── assets\n    │   │   └── logo.png\n    │   ├── components\n    │   │   └── Hello.vue\n    │   └── main.js\n    └── static\n    \n<!-- more -->    \n## package.json\n我们可以看到\n   \n       \"scripts\": {\n           \"dev\": \"node build/dev-server.js\",\n           \"build\": \"node build/build.js\",\n           \"lint\": \"eslint --ext .js,.vue src\"\n       }\n   \n   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js\n   \n## dev-server.js\n   \n        // 检查 Node 和 npm 版本\n        require('./check-versions')()\n        \n        // 获取 config/index.js 的默认配置\n        var config = require('../config')\n        \n        // 如果 Node 的环境无法判断当前是 dev / product 环境\n        // 使用 config.dev.env.NODE_ENV 作为当前的环境\n        \n        if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n        \n        // 使用 NodeJS 自带的文件路径工具\n        var path = require('path')\n        \n        // 使用 express\n        var express = require('express')\n        \n        // 使用 webpack\n        var webpack = require('webpack')\n        \n        // 一个可以强制打开浏览器并跳转到指定 url 的插件\n        var opn = require('opn')\n        \n        // 使用 proxyTable\n        var proxyMiddleware = require('http-proxy-middleware')\n        \n        // 使用 dev 环境的 webpack 配置\n        var webpackConfig = require('./webpack.dev.conf')\n        \n        // default port where dev server listens for incoming traffic\n        \n        // 如果没有指定运行端口，使用 config.dev.port 作为运行端口\n        var port = process.env.PORT || config.dev.port\n        \n        // Define HTTP proxies to your custom API backend\n        // https://github.com/chimurai/http-proxy-middleware\n        \n        // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\n        var proxyTable = config.dev.proxyTable\n        \n        // 使用 express 启动一个服务\n        var app = express()\n        \n        // 启动 webpack 进行编译\n        var compiler = webpack(webpackConfig)\n        \n        // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\n        var devMiddleware = require('webpack-dev-middleware')(compiler, {\n          publicPath: webpackConfig.output.publicPath,\n          stats: {\n            colors: true,\n            chunks: false\n          }\n        })\n        \n        // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\n        var hotMiddleware = require('webpack-hot-middleware')(compiler)\n        // force page reload when html-webpack-plugin template changes\n        compiler.plugin('compilation', function (compilation) {\n          compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n            hotMiddleware.publish({ action: 'reload' })\n            cb()\n          })\n        })\n        \n        // proxy api requests\n        // 将 proxyTable 中的请求配置挂在到启动的 express 服务上\n        Object.keys(proxyTable).forEach(function (context) {\n          var options = proxyTable[context]\n          if (typeof options === 'string') {\n            options = { target: options }\n          }\n          app.use(proxyMiddleware(context, options))\n        })\n        \n        // handle fallback for HTML5 history API\n        // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\n        app.use(require('connect-history-api-fallback')())\n        \n        // serve webpack bundle output\n        // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\n        app.use(devMiddleware)\n        \n        // enable hot-reload and state-preserving\n        // compilation error display\n        // 将 Hot-reload 挂在到 express 服务上\n        app.use(hotMiddleware)\n        \n        // serve pure static assets\n        // 拼接 static 文件夹的静态资源路径\n        var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n        // 为静态资源提供响应服务\n        app.use(staticPath, express.static('./static'))\n        \n        // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\n        module.exports = app.listen(port, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var uri = 'http://localhost:' + port\n          console.log('Listening at ' + uri + '\\n')\n        \n          // when env is testing, don't need open it\n          // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n          if (process.env.NODE_ENV !== 'testing') {\n            opn(uri)\n          }\n        })\n           \n           \n   \n## webpack.dev.conf.js\n        \n        // 同样的使用了 config/index.js\n        var config = require('../config') \n        \n        // 使用 webpack\n        var webpack = require('webpack') \n        \n        // 使用 webpack 配置合并插件\n        var merge = require('webpack-merge') \n        \n        // 使用一些小工具\n        var utils = require('./utils') \n        \n        // 加载 webpack.base.conf\n        var baseWebpackConfig = require('./webpack.base.conf') \n        \n        // 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\n        var HtmlWebpackPlugin = require('html-webpack-plugin') \n        \n        // add hot-reload related code to entry chunks\n        // 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\n        Object.keys(baseWebpackConfig.entry).forEach(function (name) {\n          baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])\n        })\n        \n        // 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\n        module.exports = merge(baseWebpackConfig, {\n          module: {\n            // 使用 styleLoaders\n            loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n          },\n          // eval-source-map is faster for development\n          // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n          devtool: '#eval-source-map',\n          plugins: [\n        \n            // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n            new webpack.DefinePlugin({\n              'process.env': config.dev.env\n            }),\n            // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n            new webpack.optimize.OccurenceOrderPlugin(),\n        \n            // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n            new webpack.HotModuleReplacementPlugin(),\n        \n            // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n            new webpack.NoErrorsPlugin(),\n            // https://github.com/ampedandwired/html-webpack-plugin\n        \n            // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n            new HtmlWebpackPlugin({\n              filename: 'index.html',\n              template: 'index.html',\n              inject: true\n            })\n          ]\n        })\n\n    \n## webpack.base.conf.js\n我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js\n        \n        // 使用 NodeJS 自带的文件路径插件\n        var path = require('path') \n        \n        // 引入 config/index.js\n        var config = require('../config') \n        \n        // 引入一些小工具\n        var utils = require('./utils') \n        \n        // 拼接我们的工作区路径为一个绝对路径\n        var projectRoot = path.resolve(__dirname, '../') \n        \n        // 将 NodeJS 环境作为我们的编译环境\n        var env = process.env.NODE_ENV\n        \n        // check env & config/index.js to decide weither to enable CSS Sourcemaps for the\n        // various preprocessor loaders added to vue-loader at the end of this file\n        \n        // 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapDev = (env === 'development' && config.dev.cssSourceMap)\n        \n        // 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapProd = (env === 'production' && config.build.productionSourceMap)\n        \n        // 最终是否使用 cssSourceMap\n        var useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n        \n        module.exports = {\n          entry: {\n              // 编译文件入口\n            app: './src/main.js' \n          },\n          output: {\n              // 编译输出的根路径\n            path: config.build.assetsRoot, \n            // 正式发布环境下编译输出的发布路径\n            publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n            // 编译输出的文件名\n            filename: '[name].js' \n          },\n          resolve: {\n            // 自动补全的扩展名\n            extensions: ['', '.js', '.vue'],\n            // 不进行自动补全或处理的文件或者文件夹\n            fallback: [path.join(__dirname, '../node_modules')],\n            alias: {\n            // 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找\n              'vue': 'vue/dist/vue.common.js',\n              'src': path.resolve(__dirname, '../src'),\n              'assets': path.resolve(__dirname, '../src/assets'),\n              'components': path.resolve(__dirname, '../src/components')\n            }\n          },\n          resolveLoader: {\n            fallback: [path.join(__dirname, '../node_modules')]\n          },\n          module: {\n            preLoaders: [\n              // 预处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.js$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              }\n            ],\n            loaders: [\n              // 需要处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'vue'\n              },\n              {\n                test: /\\.js$/,\n                loader: 'babel',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.json$/,\n                loader: 'json'\n              },\n              {\n                test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('img/[name].[hash:7].[ext]')\n                }\n              },\n              {\n                test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n                }\n              }\n            ]\n          },\n          eslint: {\n            // eslint 代码检查配置工具\n            formatter: require('eslint-friendly-formatter')\n          },\n          vue: {\n            // .vue 文件配置 loader 及工具 (autoprefixer)\n            loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n            postcss: [\n              require('autoprefixer')({\n                browsers: ['last 2 versions']\n              })\n            ]\n          }\n        }    \n        \n## config/index.js\n   \n终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js\n   \nindex.js 中有 dev 和 production 两种环境的配置 \n       \n       // see http://vuejs-templates.github.io/webpack for documentation.\n       // 不再重复介绍了 ...\n       var path = require('path')\n       \n       module.exports = {\n         // production 环境\n         build: { \n             // 使用 config/prod.env.js 中定义的编译环境\n           env: require('./prod.env'), \n           index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件\n           // 编译输出的静态资源根路径\n           assetsRoot: path.resolve(__dirname, '../dist'), \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 是否开启 cssSourceMap\n           productionSourceMap: true, \n           // Gzip off by default as many popular static hosts such as\n           // Surge or Netlify already gzip all static assets for you.\n           // Before setting to `true`, make sure to:\n           // npm install --save-dev compression-webpack-plugin\n           // 是否开启 gzip\n           productionGzip: false, \n           // 需要使用 gzip 压缩的文件扩展名\n           productionGzipExtensions: ['js', 'css'] \n         },\n         // dev 环境\n         dev: { \n             // 使用 config/dev.env.js 中定义的编译环境\n           env: require('./dev.env'), \n           // 运行测试页面的端口\n           port: 8080, \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 需要 proxyTable 代理的接口（可跨域）\n           proxyTable: {}, \n           // CSS Sourcemaps off by default because relative paths are \"buggy\"\n           // with this option, according to the CSS-Loader README\n           // (https://github.com/webpack/css-loader#sourcemaps)\n           // In our experience, they generally work as expected,\n           // just be aware of this issue when enabling this option.\n           // 是否开启 cssSourceMap\n           cssSourceMap: false \n         }\n       }\n  \n       \n至此，我们的 npm run dev 命令就讲解完毕，\n\n下面让我们来看一看执行 npm run build 命令时发生了什么 \n## build.js  \n     // https://github.com/shelljs/shelljs\n     \n     // 检查 Node 和 npm 版本\n     require('./check-versions')() \n     \n     // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\n     require('shelljs/global') \n     env.NODE_ENV = 'production'\n     \n     // 不再赘述\n     var path = require('path') \n     \n     // 加载 config.js\n     var config = require('../config') \n     \n     // 一个很好看的 loading 插件\n     var ora = require('ora') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack.prod.conf\n     var webpackConfig = require('./webpack.prod.conf') \n     \n     //  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\n     console.log(\n       '  Tip:\\n' +\n       '  Built files are meant to be served over an HTTP server.\\n' +\n       '  Opening index.html over file:// won\\'t work.\\n'\n     )\n     \n     // 使用 ora 打印出 loading + log\n     var spinner = ora('building for production...') \n     // 开始 loading 动画\n     spinner.start() \n     \n     // 拼接编译输出文件路径\n     var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n     // 删除这个文件夹 （递归删除）\n     rm('-rf', assetsPath)\n     // 创建此文件夹 \n     mkdir('-p', assetsPath)\n     // 复制 static 文件夹到我们的编译输出目录\n     cp('-R', 'static/*', assetsPath)\n     \n     //  开始 webpack 的编译\n     webpack(webpackConfig, function (err, stats) {\n       // 编译成功的回调函数\n       spinner.stop()\n       if (err) throw err\n       process.stdout.write(stats.toString({\n         colors: true,\n         modules: false,\n         children: false,\n         chunks: false,\n         chunkModules: false\n       }) + '\\n')\n     })\n     \n## webpack.prod.conf.js\n     // 不再赘述\n     var path = require('path')\n     \n     // 加载 confi.index.js\n     var config = require('../config')\n     \n     // 使用一些小工具\n     var utils = require('./utils') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack 配置合并工具\n     var merge = require('webpack-merge') \n     \n     // 加载 webpack.base.conf.js\n     var baseWebpackConfig = require('./webpack.base.conf') \n     \n     // 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n     // 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\n     var ExtractTextPlugin = require('extract-text-webpack-plugin')\n     \n     // 一个可以插入 html 并且创建新的 .html 文件的插件\n     var HtmlWebpackPlugin = require('html-webpack-plugin')\n     var env = config.build.env\n     \n     // 合并 webpack.base.conf.js\n     var webpackConfig = merge(baseWebpackConfig, {\n       module: {\n         // 使用的 loader\n         loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n       },\n       // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n       devtool: config.build.productionSourceMap ? '#source-map' : false,\n       output: {\n         // 编译输出目录\n         path: config.build.assetsRoot,\n         // 编译输出文件名\n         // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n         filename: utils.assetsPath('js/[name].[chunkhash].js'), \n         // 没有指定输出名的文件输出的文件名\n         chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n       },\n       vue: {\n         // 编译 .vue 文件时使用的 loader\n         loaders: utils.cssLoaders({\n           sourceMap: config.build.productionSourceMap,\n           extract: true\n         })\n       },\n       plugins: [\n         // 使用的插件\n         // http://vuejs.github.io/vue-loader/en/workflow/production.html\n         // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n         new webpack.DefinePlugin({\n           'process.env': env\n         }),\n         // 压缩 js (同样可以压缩 css)\n         new webpack.optimize.UglifyJsPlugin({\n           compress: {\n             warnings: false\n           }\n         }),\n         new webpack.optimize.OccurrenceOrderPlugin(),\n         // extract css into its own file\n         // 将 css 文件分离出来\n         new ExtractTextPlugin(utils.assetsPath('css/[name].[contenthash].css')),\n         // generate dist index.html with correct asset hash for caching.\n         // you can customize output by editing /index.html\n         // see https://github.com/ampedandwired/html-webpack-plugin\n         // 输入输出的 .html 文件\n         new HtmlWebpackPlugin({\n           filename: config.build.index,\n           template: 'index.html',\n           // 是否注入 html\n           inject: true, \n           // 压缩的方式\n           minify: { \n             removeComments: true,\n             collapseWhitespace: true,\n             removeAttributeQuotes: true\n             // more options:\n             // https://github.com/kangax/html-minifier#options-quick-reference\n           },\n           // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n           chunksSortMode: 'dependency'\n         }),\n         // split vendor js into its own file\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'vendor',\n           minChunks: function (module, count) {\n             // any required modules inside node_modules are extracted to vendor\n             return (\n               module.resource &&\n               /\\.js$/.test(module.resource) &&\n               module.resource.indexOf(\n                 path.join(__dirname, '../node_modules')\n               ) === 0\n             )\n           }\n         }),\n         // extract webpack runtime and module manifest to its own file in order to\n         // prevent vendor hash from being updated whenever app bundle is updated\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'manifest',\n           chunks: ['vendor']\n         })\n       ]\n     })\n     \n     // 开启 gzip 的情况下使用下方的配置\n     if (config.build.productionGzip) {\n       // 加载 compression-webpack-plugin 插件\n       var CompressionWebpackPlugin =  require('compression-webpack-plugin')\n       // 向webpackconfig.plugins中加入下方的插件\n       var reProductionGzipExtensions = '\\\\.(' + config.build.productionGzipExtensions.join('|') + '$)'\n       webpackConfig.plugins.push(\n         // 使用 compression-webpack-plugin 插件进行压缩\n         new CompressionWebpackPlugin({\n           asset: '[path].gz[query]',\n           algorithm: 'gzip',\n           test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n           threshold: 10240,\n           minRatio: 0.8\n         })\n       )\n     }\n     \n     module.exports = webpackConfig","source":"_posts/vue-cli-2-中webpack的配置-一.md","raw":"---\ntitle: 'vue-cli(#2)中webpack的配置(一)'\ndate: 2017-10-07 22:39:39\ntags:\n      -webpack\n      -vue-cli\n      -vue\n---\n这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.\n\n## 目录结构\n\n    .\n    ├── README.md\n    ├── build\n    │   ├── build.js\n    │   ├── check-versions.js\n    │   ├── dev-client.js\n    │   ├── dev-server.js\n    │   ├── utils.js\n    │   ├── webpack.base.conf.js\n    │   ├── webpack.dev.conf.js\n    │   └── webpack.prod.conf.js\n    ├── config\n    │   ├── dev.env.js\n    │   ├── index.js\n    │   └── prod.env.js\n    ├── index.html\n    ├── package.json\n    ├── src\n    │   ├── App.vue\n    │   ├── assets\n    │   │   └── logo.png\n    │   ├── components\n    │   │   └── Hello.vue\n    │   └── main.js\n    └── static\n    \n<!-- more -->    \n## package.json\n我们可以看到\n   \n       \"scripts\": {\n           \"dev\": \"node build/dev-server.js\",\n           \"build\": \"node build/build.js\",\n           \"lint\": \"eslint --ext .js,.vue src\"\n       }\n   \n   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js\n   \n## dev-server.js\n   \n        // 检查 Node 和 npm 版本\n        require('./check-versions')()\n        \n        // 获取 config/index.js 的默认配置\n        var config = require('../config')\n        \n        // 如果 Node 的环境无法判断当前是 dev / product 环境\n        // 使用 config.dev.env.NODE_ENV 作为当前的环境\n        \n        if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n        \n        // 使用 NodeJS 自带的文件路径工具\n        var path = require('path')\n        \n        // 使用 express\n        var express = require('express')\n        \n        // 使用 webpack\n        var webpack = require('webpack')\n        \n        // 一个可以强制打开浏览器并跳转到指定 url 的插件\n        var opn = require('opn')\n        \n        // 使用 proxyTable\n        var proxyMiddleware = require('http-proxy-middleware')\n        \n        // 使用 dev 环境的 webpack 配置\n        var webpackConfig = require('./webpack.dev.conf')\n        \n        // default port where dev server listens for incoming traffic\n        \n        // 如果没有指定运行端口，使用 config.dev.port 作为运行端口\n        var port = process.env.PORT || config.dev.port\n        \n        // Define HTTP proxies to your custom API backend\n        // https://github.com/chimurai/http-proxy-middleware\n        \n        // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\n        var proxyTable = config.dev.proxyTable\n        \n        // 使用 express 启动一个服务\n        var app = express()\n        \n        // 启动 webpack 进行编译\n        var compiler = webpack(webpackConfig)\n        \n        // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\n        var devMiddleware = require('webpack-dev-middleware')(compiler, {\n          publicPath: webpackConfig.output.publicPath,\n          stats: {\n            colors: true,\n            chunks: false\n          }\n        })\n        \n        // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\n        var hotMiddleware = require('webpack-hot-middleware')(compiler)\n        // force page reload when html-webpack-plugin template changes\n        compiler.plugin('compilation', function (compilation) {\n          compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n            hotMiddleware.publish({ action: 'reload' })\n            cb()\n          })\n        })\n        \n        // proxy api requests\n        // 将 proxyTable 中的请求配置挂在到启动的 express 服务上\n        Object.keys(proxyTable).forEach(function (context) {\n          var options = proxyTable[context]\n          if (typeof options === 'string') {\n            options = { target: options }\n          }\n          app.use(proxyMiddleware(context, options))\n        })\n        \n        // handle fallback for HTML5 history API\n        // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\n        app.use(require('connect-history-api-fallback')())\n        \n        // serve webpack bundle output\n        // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\n        app.use(devMiddleware)\n        \n        // enable hot-reload and state-preserving\n        // compilation error display\n        // 将 Hot-reload 挂在到 express 服务上\n        app.use(hotMiddleware)\n        \n        // serve pure static assets\n        // 拼接 static 文件夹的静态资源路径\n        var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n        // 为静态资源提供响应服务\n        app.use(staticPath, express.static('./static'))\n        \n        // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\n        module.exports = app.listen(port, function (err) {\n          if (err) {\n            console.log(err)\n            return\n          }\n          var uri = 'http://localhost:' + port\n          console.log('Listening at ' + uri + '\\n')\n        \n          // when env is testing, don't need open it\n          // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n          if (process.env.NODE_ENV !== 'testing') {\n            opn(uri)\n          }\n        })\n           \n           \n   \n## webpack.dev.conf.js\n        \n        // 同样的使用了 config/index.js\n        var config = require('../config') \n        \n        // 使用 webpack\n        var webpack = require('webpack') \n        \n        // 使用 webpack 配置合并插件\n        var merge = require('webpack-merge') \n        \n        // 使用一些小工具\n        var utils = require('./utils') \n        \n        // 加载 webpack.base.conf\n        var baseWebpackConfig = require('./webpack.base.conf') \n        \n        // 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\n        var HtmlWebpackPlugin = require('html-webpack-plugin') \n        \n        // add hot-reload related code to entry chunks\n        // 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\n        Object.keys(baseWebpackConfig.entry).forEach(function (name) {\n          baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])\n        })\n        \n        // 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\n        module.exports = merge(baseWebpackConfig, {\n          module: {\n            // 使用 styleLoaders\n            loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n          },\n          // eval-source-map is faster for development\n          // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n          devtool: '#eval-source-map',\n          plugins: [\n        \n            // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n            new webpack.DefinePlugin({\n              'process.env': config.dev.env\n            }),\n            // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n            new webpack.optimize.OccurenceOrderPlugin(),\n        \n            // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n            new webpack.HotModuleReplacementPlugin(),\n        \n            // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n            new webpack.NoErrorsPlugin(),\n            // https://github.com/ampedandwired/html-webpack-plugin\n        \n            // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n            new HtmlWebpackPlugin({\n              filename: 'index.html',\n              template: 'index.html',\n              inject: true\n            })\n          ]\n        })\n\n    \n## webpack.base.conf.js\n我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js\n        \n        // 使用 NodeJS 自带的文件路径插件\n        var path = require('path') \n        \n        // 引入 config/index.js\n        var config = require('../config') \n        \n        // 引入一些小工具\n        var utils = require('./utils') \n        \n        // 拼接我们的工作区路径为一个绝对路径\n        var projectRoot = path.resolve(__dirname, '../') \n        \n        // 将 NodeJS 环境作为我们的编译环境\n        var env = process.env.NODE_ENV\n        \n        // check env & config/index.js to decide weither to enable CSS Sourcemaps for the\n        // various preprocessor loaders added to vue-loader at the end of this file\n        \n        // 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapDev = (env === 'development' && config.dev.cssSourceMap)\n        \n        // 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\n        var cssSourceMapProd = (env === 'production' && config.build.productionSourceMap)\n        \n        // 最终是否使用 cssSourceMap\n        var useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n        \n        module.exports = {\n          entry: {\n              // 编译文件入口\n            app: './src/main.js' \n          },\n          output: {\n              // 编译输出的根路径\n            path: config.build.assetsRoot, \n            // 正式发布环境下编译输出的发布路径\n            publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n            // 编译输出的文件名\n            filename: '[name].js' \n          },\n          resolve: {\n            // 自动补全的扩展名\n            extensions: ['', '.js', '.vue'],\n            // 不进行自动补全或处理的文件或者文件夹\n            fallback: [path.join(__dirname, '../node_modules')],\n            alias: {\n            // 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找\n              'vue': 'vue/dist/vue.common.js',\n              'src': path.resolve(__dirname, '../src'),\n              'assets': path.resolve(__dirname, '../src/assets'),\n              'components': path.resolve(__dirname, '../src/components')\n            }\n          },\n          resolveLoader: {\n            fallback: [path.join(__dirname, '../node_modules')]\n          },\n          module: {\n            preLoaders: [\n              // 预处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.js$/,\n                loader: 'eslint',\n                include: projectRoot,\n                exclude: /node_modules/\n              }\n            ],\n            loaders: [\n              // 需要处理的文件及使用的 loader\n              {\n                test: /\\.vue$/,\n                loader: 'vue'\n              },\n              {\n                test: /\\.js$/,\n                loader: 'babel',\n                include: projectRoot,\n                exclude: /node_modules/\n              },\n              {\n                test: /\\.json$/,\n                loader: 'json'\n              },\n              {\n                test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('img/[name].[hash:7].[ext]')\n                }\n              },\n              {\n                test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n                loader: 'url',\n                query: {\n                  limit: 10000,\n                  name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n                }\n              }\n            ]\n          },\n          eslint: {\n            // eslint 代码检查配置工具\n            formatter: require('eslint-friendly-formatter')\n          },\n          vue: {\n            // .vue 文件配置 loader 及工具 (autoprefixer)\n            loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n            postcss: [\n              require('autoprefixer')({\n                browsers: ['last 2 versions']\n              })\n            ]\n          }\n        }    \n        \n## config/index.js\n   \n终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js\n   \nindex.js 中有 dev 和 production 两种环境的配置 \n       \n       // see http://vuejs-templates.github.io/webpack for documentation.\n       // 不再重复介绍了 ...\n       var path = require('path')\n       \n       module.exports = {\n         // production 环境\n         build: { \n             // 使用 config/prod.env.js 中定义的编译环境\n           env: require('./prod.env'), \n           index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件\n           // 编译输出的静态资源根路径\n           assetsRoot: path.resolve(__dirname, '../dist'), \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 是否开启 cssSourceMap\n           productionSourceMap: true, \n           // Gzip off by default as many popular static hosts such as\n           // Surge or Netlify already gzip all static assets for you.\n           // Before setting to `true`, make sure to:\n           // npm install --save-dev compression-webpack-plugin\n           // 是否开启 gzip\n           productionGzip: false, \n           // 需要使用 gzip 压缩的文件扩展名\n           productionGzipExtensions: ['js', 'css'] \n         },\n         // dev 环境\n         dev: { \n             // 使用 config/dev.env.js 中定义的编译环境\n           env: require('./dev.env'), \n           // 运行测试页面的端口\n           port: 8080, \n           // 编译输出的二级目录\n           assetsSubDirectory: 'static', \n           // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n           assetsPublicPath: '/', \n           // 需要 proxyTable 代理的接口（可跨域）\n           proxyTable: {}, \n           // CSS Sourcemaps off by default because relative paths are \"buggy\"\n           // with this option, according to the CSS-Loader README\n           // (https://github.com/webpack/css-loader#sourcemaps)\n           // In our experience, they generally work as expected,\n           // just be aware of this issue when enabling this option.\n           // 是否开启 cssSourceMap\n           cssSourceMap: false \n         }\n       }\n  \n       \n至此，我们的 npm run dev 命令就讲解完毕，\n\n下面让我们来看一看执行 npm run build 命令时发生了什么 \n## build.js  \n     // https://github.com/shelljs/shelljs\n     \n     // 检查 Node 和 npm 版本\n     require('./check-versions')() \n     \n     // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\n     require('shelljs/global') \n     env.NODE_ENV = 'production'\n     \n     // 不再赘述\n     var path = require('path') \n     \n     // 加载 config.js\n     var config = require('../config') \n     \n     // 一个很好看的 loading 插件\n     var ora = require('ora') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack.prod.conf\n     var webpackConfig = require('./webpack.prod.conf') \n     \n     //  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\n     console.log(\n       '  Tip:\\n' +\n       '  Built files are meant to be served over an HTTP server.\\n' +\n       '  Opening index.html over file:// won\\'t work.\\n'\n     )\n     \n     // 使用 ora 打印出 loading + log\n     var spinner = ora('building for production...') \n     // 开始 loading 动画\n     spinner.start() \n     \n     // 拼接编译输出文件路径\n     var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n     // 删除这个文件夹 （递归删除）\n     rm('-rf', assetsPath)\n     // 创建此文件夹 \n     mkdir('-p', assetsPath)\n     // 复制 static 文件夹到我们的编译输出目录\n     cp('-R', 'static/*', assetsPath)\n     \n     //  开始 webpack 的编译\n     webpack(webpackConfig, function (err, stats) {\n       // 编译成功的回调函数\n       spinner.stop()\n       if (err) throw err\n       process.stdout.write(stats.toString({\n         colors: true,\n         modules: false,\n         children: false,\n         chunks: false,\n         chunkModules: false\n       }) + '\\n')\n     })\n     \n## webpack.prod.conf.js\n     // 不再赘述\n     var path = require('path')\n     \n     // 加载 confi.index.js\n     var config = require('../config')\n     \n     // 使用一些小工具\n     var utils = require('./utils') \n     \n     // 加载 webpack\n     var webpack = require('webpack') \n     \n     // 加载 webpack 配置合并工具\n     var merge = require('webpack-merge') \n     \n     // 加载 webpack.base.conf.js\n     var baseWebpackConfig = require('./webpack.base.conf') \n     \n     // 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n     // 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\n     var ExtractTextPlugin = require('extract-text-webpack-plugin')\n     \n     // 一个可以插入 html 并且创建新的 .html 文件的插件\n     var HtmlWebpackPlugin = require('html-webpack-plugin')\n     var env = config.build.env\n     \n     // 合并 webpack.base.conf.js\n     var webpackConfig = merge(baseWebpackConfig, {\n       module: {\n         // 使用的 loader\n         loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n       },\n       // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n       devtool: config.build.productionSourceMap ? '#source-map' : false,\n       output: {\n         // 编译输出目录\n         path: config.build.assetsRoot,\n         // 编译输出文件名\n         // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n         filename: utils.assetsPath('js/[name].[chunkhash].js'), \n         // 没有指定输出名的文件输出的文件名\n         chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n       },\n       vue: {\n         // 编译 .vue 文件时使用的 loader\n         loaders: utils.cssLoaders({\n           sourceMap: config.build.productionSourceMap,\n           extract: true\n         })\n       },\n       plugins: [\n         // 使用的插件\n         // http://vuejs.github.io/vue-loader/en/workflow/production.html\n         // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n         new webpack.DefinePlugin({\n           'process.env': env\n         }),\n         // 压缩 js (同样可以压缩 css)\n         new webpack.optimize.UglifyJsPlugin({\n           compress: {\n             warnings: false\n           }\n         }),\n         new webpack.optimize.OccurrenceOrderPlugin(),\n         // extract css into its own file\n         // 将 css 文件分离出来\n         new ExtractTextPlugin(utils.assetsPath('css/[name].[contenthash].css')),\n         // generate dist index.html with correct asset hash for caching.\n         // you can customize output by editing /index.html\n         // see https://github.com/ampedandwired/html-webpack-plugin\n         // 输入输出的 .html 文件\n         new HtmlWebpackPlugin({\n           filename: config.build.index,\n           template: 'index.html',\n           // 是否注入 html\n           inject: true, \n           // 压缩的方式\n           minify: { \n             removeComments: true,\n             collapseWhitespace: true,\n             removeAttributeQuotes: true\n             // more options:\n             // https://github.com/kangax/html-minifier#options-quick-reference\n           },\n           // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n           chunksSortMode: 'dependency'\n         }),\n         // split vendor js into its own file\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'vendor',\n           minChunks: function (module, count) {\n             // any required modules inside node_modules are extracted to vendor\n             return (\n               module.resource &&\n               /\\.js$/.test(module.resource) &&\n               module.resource.indexOf(\n                 path.join(__dirname, '../node_modules')\n               ) === 0\n             )\n           }\n         }),\n         // extract webpack runtime and module manifest to its own file in order to\n         // prevent vendor hash from being updated whenever app bundle is updated\n         // 没有指定输出文件名的文件输出的静态文件名\n         new webpack.optimize.CommonsChunkPlugin({\n           name: 'manifest',\n           chunks: ['vendor']\n         })\n       ]\n     })\n     \n     // 开启 gzip 的情况下使用下方的配置\n     if (config.build.productionGzip) {\n       // 加载 compression-webpack-plugin 插件\n       var CompressionWebpackPlugin =  require('compression-webpack-plugin')\n       // 向webpackconfig.plugins中加入下方的插件\n       var reProductionGzipExtensions = '\\\\.(' + config.build.productionGzipExtensions.join('|') + '$)'\n       webpackConfig.plugins.push(\n         // 使用 compression-webpack-plugin 插件进行压缩\n         new CompressionWebpackPlugin({\n           asset: '[path].gz[query]',\n           algorithm: 'gzip',\n           test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n           threshold: 10240,\n           minRatio: 0.8\n         })\n       )\n     }\n     \n     module.exports = webpackConfig","slug":"vue-cli-2-中webpack的配置-一","published":1,"updated":"2017-10-07T15:29:06.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8w00056ww3tdg51tr7","content":"<p>这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── index.html\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   └── logo.png\n│   ├── components\n│   │   └── Hello.vue\n│   └── main.js\n└── static\n</code></pre><a id=\"more\"></a>    \n<h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p>我们可以看到</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;\n}\n</code></pre><p>   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js</p>\n<h2 id=\"dev-server-js\"><a href=\"#dev-server-js\" class=\"headerlink\" title=\"dev-server.js\"></a>dev-server.js</h2><pre><code>// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)()\n\n// 获取 config/index.js 的默认配置\nvar config = require(&apos;../config&apos;)\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require(&apos;path&apos;)\n\n// 使用 express\nvar express = require(&apos;express&apos;)\n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;)\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require(&apos;opn&apos;)\n\n// 使用 proxyTable\nvar proxyMiddleware = require(&apos;http-proxy-middleware&apos;)\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require(&apos;./webpack.dev.conf&apos;)\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin(&apos;compilation&apos;, function (compilation) {\n  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) {\n    hotMiddleware.publish({ action: &apos;reload&apos; })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === &apos;string&apos;) {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require(&apos;connect-history-api-fallback&apos;)())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static(&apos;./static&apos;))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = &apos;http://localhost:&apos; + port\n  console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n\n  // when env is testing, don&apos;t need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== &apos;testing&apos;) {\n    opn(uri)\n  }\n})\n</code></pre><h2 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a>webpack.dev.conf.js</h2><pre><code>// 同样的使用了 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 使用 webpack 配置合并插件\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack.base.conf\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) \n\n// add hot-reload related code to entry chunks\n// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\nObject.keys(baseWebpackConfig.entry).forEach(function (name) {\n  baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat(baseWebpackConfig.entry[name])\n})\n\n// 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\nmodule.exports = merge(baseWebpackConfig, {\n  module: {\n    // 使用 styleLoaders\n    loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n  },\n  // eval-source-map is faster for development\n  // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n  devtool: &apos;#eval-source-map&apos;,\n  plugins: [\n\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n    // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n    new webpack.optimize.OccurenceOrderPlugin(),\n\n    // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n    new webpack.HotModuleReplacementPlugin(),\n\n    // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n    new webpack.NoErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n\n    // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n    new HtmlWebpackPlugin({\n      filename: &apos;index.html&apos;,\n      template: &apos;index.html&apos;,\n      inject: true\n    })\n  ]\n})\n</code></pre><h2 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a>webpack.base.conf.js</h2><p>我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js</p>\n<pre><code>// 使用 NodeJS 自带的文件路径插件\nvar path = require(&apos;path&apos;) \n\n// 引入 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 引入一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 拼接我们的工作区路径为一个绝对路径\nvar projectRoot = path.resolve(__dirname, &apos;../&apos;) \n\n// 将 NodeJS 环境作为我们的编译环境\nvar env = process.env.NODE_ENV\n\n// check env &amp; config/index.js to decide weither to enable CSS Sourcemaps for the\n// various preprocessor loaders added to vue-loader at the end of this file\n\n// 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapDev = (env === &apos;development&apos; &amp;&amp; config.dev.cssSourceMap)\n\n// 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapProd = (env === &apos;production&apos; &amp;&amp; config.build.productionSourceMap)\n\n// 最终是否使用 cssSourceMap\nvar useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n\nmodule.exports = {\n  entry: {\n      // 编译文件入口\n    app: &apos;./src/main.js&apos; \n  },\n  output: {\n      // 编译输出的根路径\n    path: config.build.assetsRoot, \n    // 正式发布环境下编译输出的发布路径\n    publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n    // 编译输出的文件名\n    filename: &apos;[name].js&apos; \n  },\n  resolve: {\n    // 自动补全的扩展名\n    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;],\n    // 不进行自动补全或处理的文件或者文件夹\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],\n    alias: {\n    // 默认路径代理，例如 import Vue from &apos;vue&apos;，会自动到 &apos;vue/dist/vue.common.js&apos;中寻找\n      &apos;vue&apos;: &apos;vue/dist/vue.common.js&apos;,\n      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),\n      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),\n      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)\n    }\n  },\n  resolveLoader: {\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)]\n  },\n  module: {\n    preLoaders: [\n      // 预处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      }\n    ],\n    loaders: [\n      // 需要处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue&apos;\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: &apos;json&apos;\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  },\n  eslint: {\n    // eslint 代码检查配置工具\n    formatter: require(&apos;eslint-friendly-formatter&apos;)\n  },\n  vue: {\n    // .vue 文件配置 loader 及工具 (autoprefixer)\n    loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n    postcss: [\n      require(&apos;autoprefixer&apos;)({\n        browsers: [&apos;last 2 versions&apos;]\n      })\n    ]\n  }\n}    \n</code></pre><h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><p>终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js</p>\n<p>index.js 中有 dev 和 production 两种环境的配置 </p>\n<pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// 不再重复介绍了 ...\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n  // production 环境\n  build: { \n      // 使用 config/prod.env.js 中定义的编译环境\n    env: require(&apos;./prod.env&apos;), \n    index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件\n    // 编译输出的静态资源根路径\n    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 是否开启 cssSourceMap\n    productionSourceMap: true, \n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    // 是否开启 gzip\n    productionGzip: false, \n    // 需要使用 gzip 压缩的文件扩展名\n    productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;] \n  },\n  // dev 环境\n  dev: { \n      // 使用 config/dev.env.js 中定义的编译环境\n    env: require(&apos;./dev.env&apos;), \n    // 运行测试页面的端口\n    port: 8080, \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 需要 proxyTable 代理的接口（可跨域）\n    proxyTable: {}, \n    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n    // with this option, according to the CSS-Loader README\n    // (https://github.com/webpack/css-loader#sourcemaps)\n    // In our experience, they generally work as expected,\n    // just be aware of this issue when enabling this option.\n    // 是否开启 cssSourceMap\n    cssSourceMap: false \n  }\n}\n</code></pre><p>至此，我们的 npm run dev 命令就讲解完毕，</p>\n<p>下面让我们来看一看执行 npm run build 命令时发生了什么 </p>\n<h2 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h2><pre><code>// https://github.com/shelljs/shelljs\n\n// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)() \n\n// 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\nrequire(&apos;shelljs/global&apos;) \nenv.NODE_ENV = &apos;production&apos;\n\n// 不再赘述\nvar path = require(&apos;path&apos;) \n\n// 加载 config.js\nvar config = require(&apos;../config&apos;) \n\n// 一个很好看的 loading 插件\nvar ora = require(&apos;ora&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack.prod.conf\nvar webpackConfig = require(&apos;./webpack.prod.conf&apos;) \n\n//  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\nconsole.log(\n  &apos;  Tip:\\n&apos; +\n  &apos;  Built files are meant to be served over an HTTP server.\\n&apos; +\n  &apos;  Opening index.html over file:// won\\&apos;t work.\\n&apos;\n)\n\n// 使用 ora 打印出 loading + log\nvar spinner = ora(&apos;building for production...&apos;) \n// 开始 loading 动画\nspinner.start() \n\n// 拼接编译输出文件路径\nvar assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n// 删除这个文件夹 （递归删除）\nrm(&apos;-rf&apos;, assetsPath)\n// 创建此文件夹 \nmkdir(&apos;-p&apos;, assetsPath)\n// 复制 static 文件夹到我们的编译输出目录\ncp(&apos;-R&apos;, &apos;static/*&apos;, assetsPath)\n\n//  开始 webpack 的编译\nwebpack(webpackConfig, function (err, stats) {\n  // 编译成功的回调函数\n  spinner.stop()\n  if (err) throw err\n  process.stdout.write(stats.toString({\n    colors: true,\n    modules: false,\n    children: false,\n    chunks: false,\n    chunkModules: false\n  }) + &apos;\\n&apos;)\n})\n</code></pre><h2 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a>webpack.prod.conf.js</h2><pre><code>// 不再赘述\nvar path = require(&apos;path&apos;)\n\n// 加载 confi.index.js\nvar config = require(&apos;../config&apos;)\n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack 配置合并工具\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 加载 webpack.base.conf.js\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n// 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\nvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)\n\n// 一个可以插入 html 并且创建新的 .html 文件的插件\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)\nvar env = config.build.env\n\n// 合并 webpack.base.conf.js\nvar webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    // 使用的 loader\n    loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n  },\n  // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n  devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false,\n  output: {\n    // 编译输出目录\n    path: config.build.assetsRoot,\n    // 编译输出文件名\n    // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), \n    // 没有指定输出名的文件输出的文件名\n    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)\n  },\n  vue: {\n    // 编译 .vue 文件时使用的 loader\n    loaders: utils.cssLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true\n    })\n  },\n  plugins: [\n    // 使用的插件\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: env\n    }),\n    // 压缩 js (同样可以压缩 css)\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    // extract css into its own file\n    // 将 css 文件分离出来\n    new ExtractTextPlugin(utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    // 输入输出的 .html 文件\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: &apos;index.html&apos;,\n      // 是否注入 html\n      inject: true, \n      // 压缩的方式\n      minify: { \n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: &apos;dependency&apos;\n    }),\n    // split vendor js into its own file\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    })\n  ]\n})\n\n// 开启 gzip 的情况下使用下方的配置\nif (config.build.productionGzip) {\n  // 加载 compression-webpack-plugin 插件\n  var CompressionWebpackPlugin =  require(&apos;compression-webpack-plugin&apos;)\n  // 向webpackconfig.plugins中加入下方的插件\n  var reProductionGzipExtensions = &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;$)&apos;\n  webpackConfig.plugins.push(\n    // 使用 compression-webpack-plugin 插件进行压缩\n    new CompressionWebpackPlugin({\n      asset: &apos;[path].gz[query]&apos;,\n      algorithm: &apos;gzip&apos;,\n      test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nmodule.exports = webpackConfig\n</code></pre>","site":{"data":{}},"excerpt":"<p>这篇基本上转载自滴滴前端团队的一片文章,感谢这样优秀的前端团队.</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>.\n├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── index.html\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   └── logo.png\n│   ├── components\n│   │   └── Hello.vue\n│   └── main.js\n└── static\n</code></pre>","more":"<h2 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h2><p>我们可以看到</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;\n}\n</code></pre><p>   当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js</p>\n<h2 id=\"dev-server-js\"><a href=\"#dev-server-js\" class=\"headerlink\" title=\"dev-server.js\"></a>dev-server.js</h2><pre><code>// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)()\n\n// 获取 config/index.js 的默认配置\nvar config = require(&apos;../config&apos;)\n\n// 如果 Node 的环境无法判断当前是 dev / product 环境\n// 使用 config.dev.env.NODE_ENV 作为当前的环境\n\nif (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)\n\n// 使用 NodeJS 自带的文件路径工具\nvar path = require(&apos;path&apos;)\n\n// 使用 express\nvar express = require(&apos;express&apos;)\n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;)\n\n// 一个可以强制打开浏览器并跳转到指定 url 的插件\nvar opn = require(&apos;opn&apos;)\n\n// 使用 proxyTable\nvar proxyMiddleware = require(&apos;http-proxy-middleware&apos;)\n\n// 使用 dev 环境的 webpack 配置\nvar webpackConfig = require(&apos;./webpack.dev.conf&apos;)\n\n// default port where dev server listens for incoming traffic\n\n// 如果没有指定运行端口，使用 config.dev.port 作为运行端口\nvar port = process.env.PORT || config.dev.port\n\n// Define HTTP proxies to your custom API backend\n// https://github.com/chimurai/http-proxy-middleware\n\n// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置\nvar proxyTable = config.dev.proxyTable\n\n// 使用 express 启动一个服务\nvar app = express()\n\n// 启动 webpack 进行编译\nvar compiler = webpack(webpackConfig)\n\n// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中\nvar devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, {\n  publicPath: webpackConfig.output.publicPath,\n  stats: {\n    colors: true,\n    chunks: false\n  }\n})\n\n// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload\nvar hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)\n// force page reload when html-webpack-plugin template changes\ncompiler.plugin(&apos;compilation&apos;, function (compilation) {\n  compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function (data, cb) {\n    hotMiddleware.publish({ action: &apos;reload&apos; })\n    cb()\n  })\n})\n\n// proxy api requests\n// 将 proxyTable 中的请求配置挂在到启动的 express 服务上\nObject.keys(proxyTable).forEach(function (context) {\n  var options = proxyTable[context]\n  if (typeof options === &apos;string&apos;) {\n    options = { target: options }\n  }\n  app.use(proxyMiddleware(context, options))\n})\n\n// handle fallback for HTML5 history API\n// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址\napp.use(require(&apos;connect-history-api-fallback&apos;)())\n\n// serve webpack bundle output\n// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上\napp.use(devMiddleware)\n\n// enable hot-reload and state-preserving\n// compilation error display\n// 将 Hot-reload 挂在到 express 服务上\napp.use(hotMiddleware)\n\n// serve pure static assets\n// 拼接 static 文件夹的静态资源路径\nvar staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)\n// 为静态资源提供响应服务\napp.use(staticPath, express.static(&apos;./static&apos;))\n\n// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露\nmodule.exports = app.listen(port, function (err) {\n  if (err) {\n    console.log(err)\n    return\n  }\n  var uri = &apos;http://localhost:&apos; + port\n  console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n\n  // when env is testing, don&apos;t need open it\n  // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址\n  if (process.env.NODE_ENV !== &apos;testing&apos;) {\n    opn(uri)\n  }\n})\n</code></pre><h2 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a>webpack.dev.conf.js</h2><pre><code>// 同样的使用了 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 使用 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 使用 webpack 配置合并插件\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack.base.conf\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) \n\n// add hot-reload related code to entry chunks\n// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前\nObject.keys(baseWebpackConfig.entry).forEach(function (name) {\n  baseWebpackConfig.entry[name] = [&apos;./build/dev-client&apos;].concat(baseWebpackConfig.entry[name])\n})\n\n// 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并\nmodule.exports = merge(baseWebpackConfig, {\n  module: {\n    // 使用 styleLoaders\n    loaders: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })\n  },\n  // eval-source-map is faster for development\n  // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解\n  devtool: &apos;#eval-source-map&apos;,\n  plugins: [\n\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n    // https://github.com/glenjamin/webpack-hot-middleware#installation--usage\n    new webpack.optimize.OccurenceOrderPlugin(),\n\n    // HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件\n    new webpack.HotModuleReplacementPlugin(),\n\n    // 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错\n    new webpack.NoErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n\n    // 将 index.html 作为入口，注入 html 代码后生成 index.html文件\n    new HtmlWebpackPlugin({\n      filename: &apos;index.html&apos;,\n      template: &apos;index.html&apos;,\n      inject: true\n    })\n  ]\n})\n</code></pre><h2 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a>webpack.base.conf.js</h2><p>我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js</p>\n<pre><code>// 使用 NodeJS 自带的文件路径插件\nvar path = require(&apos;path&apos;) \n\n// 引入 config/index.js\nvar config = require(&apos;../config&apos;) \n\n// 引入一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 拼接我们的工作区路径为一个绝对路径\nvar projectRoot = path.resolve(__dirname, &apos;../&apos;) \n\n// 将 NodeJS 环境作为我们的编译环境\nvar env = process.env.NODE_ENV\n\n// check env &amp; config/index.js to decide weither to enable CSS Sourcemaps for the\n// various preprocessor loaders added to vue-loader at the end of this file\n\n// 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapDev = (env === &apos;development&apos; &amp;&amp; config.dev.cssSourceMap)\n\n// 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置\nvar cssSourceMapProd = (env === &apos;production&apos; &amp;&amp; config.build.productionSourceMap)\n\n// 最终是否使用 cssSourceMap\nvar useCssSourceMap = cssSourceMapDev || cssSourceMapProd\n\nmodule.exports = {\n  entry: {\n      // 编译文件入口\n    app: &apos;./src/main.js&apos; \n  },\n  output: {\n      // 编译输出的根路径\n    path: config.build.assetsRoot, \n    // 正式发布环境下编译输出的发布路径\n    publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, \n    // 编译输出的文件名\n    filename: &apos;[name].js&apos; \n  },\n  resolve: {\n    // 自动补全的扩展名\n    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;],\n    // 不进行自动补全或处理的文件或者文件夹\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],\n    alias: {\n    // 默认路径代理，例如 import Vue from &apos;vue&apos;，会自动到 &apos;vue/dist/vue.common.js&apos;中寻找\n      &apos;vue&apos;: &apos;vue/dist/vue.common.js&apos;,\n      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),\n      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),\n      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)\n    }\n  },\n  resolveLoader: {\n    fallback: [path.join(__dirname, &apos;../node_modules&apos;)]\n  },\n  module: {\n    preLoaders: [\n      // 预处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;eslint&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      }\n    ],\n    loaders: [\n      // 需要处理的文件及使用的 loader\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue&apos;\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel&apos;,\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: &apos;json&apos;\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url&apos;,\n        query: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  },\n  eslint: {\n    // eslint 代码检查配置工具\n    formatter: require(&apos;eslint-friendly-formatter&apos;)\n  },\n  vue: {\n    // .vue 文件配置 loader 及工具 (autoprefixer)\n    loaders: utils.cssLoaders({ sourceMap: useCssSourceMap }),\n    postcss: [\n      require(&apos;autoprefixer&apos;)({\n        browsers: [&apos;last 2 versions&apos;]\n      })\n    ]\n  }\n}    \n</code></pre><h2 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h2><p>终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js</p>\n<p>index.js 中有 dev 和 production 两种环境的配置 </p>\n<pre><code>// see http://vuejs-templates.github.io/webpack for documentation.\n// 不再重复介绍了 ...\nvar path = require(&apos;path&apos;)\n\nmodule.exports = {\n  // production 环境\n  build: { \n      // 使用 config/prod.env.js 中定义的编译环境\n    env: require(&apos;./prod.env&apos;), \n    index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 编译输入的 index.html 文件\n    // 编译输出的静态资源根路径\n    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 是否开启 cssSourceMap\n    productionSourceMap: true, \n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    // 是否开启 gzip\n    productionGzip: false, \n    // 需要使用 gzip 压缩的文件扩展名\n    productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;] \n  },\n  // dev 环境\n  dev: { \n      // 使用 config/dev.env.js 中定义的编译环境\n    env: require(&apos;./dev.env&apos;), \n    // 运行测试页面的端口\n    port: 8080, \n    // 编译输出的二级目录\n    assetsSubDirectory: &apos;static&apos;, \n    // 编译发布上线路径的根目录，可配置为资源服务器域名或 CDN 域名\n    assetsPublicPath: &apos;/&apos;, \n    // 需要 proxyTable 代理的接口（可跨域）\n    proxyTable: {}, \n    // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;\n    // with this option, according to the CSS-Loader README\n    // (https://github.com/webpack/css-loader#sourcemaps)\n    // In our experience, they generally work as expected,\n    // just be aware of this issue when enabling this option.\n    // 是否开启 cssSourceMap\n    cssSourceMap: false \n  }\n}\n</code></pre><p>至此，我们的 npm run dev 命令就讲解完毕，</p>\n<p>下面让我们来看一看执行 npm run build 命令时发生了什么 </p>\n<h2 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a>build.js</h2><pre><code>// https://github.com/shelljs/shelljs\n\n// 检查 Node 和 npm 版本\nrequire(&apos;./check-versions&apos;)() \n\n// 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell\nrequire(&apos;shelljs/global&apos;) \nenv.NODE_ENV = &apos;production&apos;\n\n// 不再赘述\nvar path = require(&apos;path&apos;) \n\n// 加载 config.js\nvar config = require(&apos;../config&apos;) \n\n// 一个很好看的 loading 插件\nvar ora = require(&apos;ora&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack.prod.conf\nvar webpackConfig = require(&apos;./webpack.prod.conf&apos;) \n\n//  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页\nconsole.log(\n  &apos;  Tip:\\n&apos; +\n  &apos;  Built files are meant to be served over an HTTP server.\\n&apos; +\n  &apos;  Opening index.html over file:// won\\&apos;t work.\\n&apos;\n)\n\n// 使用 ora 打印出 loading + log\nvar spinner = ora(&apos;building for production...&apos;) \n// 开始 loading 动画\nspinner.start() \n\n// 拼接编译输出文件路径\nvar assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)\n// 删除这个文件夹 （递归删除）\nrm(&apos;-rf&apos;, assetsPath)\n// 创建此文件夹 \nmkdir(&apos;-p&apos;, assetsPath)\n// 复制 static 文件夹到我们的编译输出目录\ncp(&apos;-R&apos;, &apos;static/*&apos;, assetsPath)\n\n//  开始 webpack 的编译\nwebpack(webpackConfig, function (err, stats) {\n  // 编译成功的回调函数\n  spinner.stop()\n  if (err) throw err\n  process.stdout.write(stats.toString({\n    colors: true,\n    modules: false,\n    children: false,\n    chunks: false,\n    chunkModules: false\n  }) + &apos;\\n&apos;)\n})\n</code></pre><h2 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a>webpack.prod.conf.js</h2><pre><code>// 不再赘述\nvar path = require(&apos;path&apos;)\n\n// 加载 confi.index.js\nvar config = require(&apos;../config&apos;)\n\n// 使用一些小工具\nvar utils = require(&apos;./utils&apos;) \n\n// 加载 webpack\nvar webpack = require(&apos;webpack&apos;) \n\n// 加载 webpack 配置合并工具\nvar merge = require(&apos;webpack-merge&apos;) \n\n// 加载 webpack.base.conf.js\nvar baseWebpackConfig = require(&apos;./webpack.base.conf&apos;) \n\n// 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开\n// 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件\nvar ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)\n\n// 一个可以插入 html 并且创建新的 .html 文件的插件\nvar HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)\nvar env = config.build.env\n\n// 合并 webpack.base.conf.js\nvar webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    // 使用的 loader\n    loaders: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true })\n  },\n  // 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章\n  devtool: config.build.productionSourceMap ? &apos;#source-map&apos; : false,\n  output: {\n    // 编译输出目录\n    path: config.build.assetsRoot,\n    // 编译输出文件名\n    // 我们可以在 hash 后加 :6 决定使用几位 hash 值\n    filename: utils.assetsPath(&apos;js/[name].[chunkhash].js&apos;), \n    // 没有指定输出名的文件输出的文件名\n    chunkFilename: utils.assetsPath(&apos;js/[id].[chunkhash].js&apos;)\n  },\n  vue: {\n    // 编译 .vue 文件时使用的 loader\n    loaders: utils.cssLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true\n    })\n  },\n  plugins: [\n    // 使用的插件\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: env\n    }),\n    // 压缩 js (同样可以压缩 css)\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    // extract css into its own file\n    // 将 css 文件分离出来\n    new ExtractTextPlugin(utils.assetsPath(&apos;css/[name].[contenthash].css&apos;)),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    // 输入输出的 .html 文件\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: &apos;index.html&apos;,\n      // 是否注入 html\n      inject: true, \n      // 压缩的方式\n      minify: { \n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: &apos;dependency&apos;\n    }),\n    // split vendor js into its own file\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    // 没有指定输出文件名的文件输出的静态文件名\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    })\n  ]\n})\n\n// 开启 gzip 的情况下使用下方的配置\nif (config.build.productionGzip) {\n  // 加载 compression-webpack-plugin 插件\n  var CompressionWebpackPlugin =  require(&apos;compression-webpack-plugin&apos;)\n  // 向webpackconfig.plugins中加入下方的插件\n  var reProductionGzipExtensions = &apos;\\\\.(&apos; + config.build.productionGzipExtensions.join(&apos;|&apos;) + &apos;$)&apos;\n  webpackConfig.plugins.push(\n    // 使用 compression-webpack-plugin 插件进行压缩\n    new CompressionWebpackPlugin({\n      asset: &apos;[path].gz[query]&apos;,\n      algorithm: &apos;gzip&apos;,\n      test: new RegExp(reProductionGzipExtensions), // 注：此处因有代码格式化的bug，与源码有差异\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nmodule.exports = webpackConfig\n</code></pre>"},{"title":"vue-cli中process.env.NODE_ENV","date":"2017-10-08T09:25:32.000Z","_content":"看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development\n    \n    // webpack.base.config.js\n    output: {\n        path: config.build.assetsRoot,\n        filename: '[name].js',\n        publicPath: process.env.NODE_ENV === 'production'\n          ? config.build.assetsPublicPath\n          : config.dev.assetsPublicPath\n      },\n      \n      \n通过看了不同的文章,大概有所了解.\n\n请参考[process.env](http://cnodejs.org/topic/57a409657a922d6f358cd22d)\n\n[改变运行脚本的环境变量](http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html)\n\n[业务代码如何判断生产/开发环境](http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html)        \n\n[DefinePlugin中的淫技巧](http://blog.csdn.net/sinat_17775997/article/details/70140322)\n\n<!-- more -->        \n\n### process.env\nprocess对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。\n\nprocess.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：\n\n    console.log(process.env);\n    console.log('username: ' + process.env.USERNAME);\n    console.log('PATH: ' + process.env.PATH);\n\n### webpack 开发和生产的区别\n开发环境(development)和生产环境(production)的构建目标差异很大。\n\n在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。\n\n而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。\n\n由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。\n\n分别为\n\nwebpack.config.js\n\nwebpack.dev.js\n\nwebpack.production.js\n\n### 如何区分生产环境还是开发环境\n引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.\n\n在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.\n    \n        // webpack.base.config.js\n        output: {\n            path: config.build.assetsRoot,\n            filename: '[name].js',\n            publicPath: process.env.NODE_ENV === 'production'\n              ? config.build.assetsPublicPath\n              : config.dev.assetsPublicPath\n          },\n \n      \n###  process.env.NODE_ENV如何设置 \n\n1. 因为process是nodejs全局变量,可以通过命令行设置\n        \n        \n        export NODE_ENV = production && webpack\n        \n        export NODE_ENV = dev && webpack\n        \n2. 也可以通过package.json设置\n        \n        \n            {\n              \"scripts\": {\n                \"dev\": \"export NODE_ENV=dev&&webpack  --progress --colors\",\n                \"production\": \"export NODE_ENV=production&&webpack  --progress --colors\",\n              },\n\n3. 也可以借助webpack.DefinePlugin插件,在代码里面设置,如\n          \n             \n                //webpack.dev.js\n             plugins: [\n                new webpack.DefinePlugin({\n                  'process.env': config.dev.env\n                }),\n             \n             //config/index.js\n             dev: {\n                 env: require('./dev.env'),\n                 port: 8080,\n    \n            //config/dev.env.js\n            var merge = require('webpack-merge')\n            var prodEnv = require('./prod.env')\n            \n            module.exports = merge(prodEnv, {\n              NODE_ENV: '\"development\"'\n            })\n\n但是在build.js中  process.env.NODE_ENV = 'production'  ,不知道这个和webpack.prod.js里面的有什么区别.\n     ","source":"_posts/vue-cli中process-env-NODE-ENV.md","raw":"---\ntitle: vue-cli中process.env.NODE_ENV\ndate: 2017-10-08 17:25:32\ntags:\n    - vue-cli\n    - webpack\n    - nodejs\n---\n看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development\n    \n    // webpack.base.config.js\n    output: {\n        path: config.build.assetsRoot,\n        filename: '[name].js',\n        publicPath: process.env.NODE_ENV === 'production'\n          ? config.build.assetsPublicPath\n          : config.dev.assetsPublicPath\n      },\n      \n      \n通过看了不同的文章,大概有所了解.\n\n请参考[process.env](http://cnodejs.org/topic/57a409657a922d6f358cd22d)\n\n[改变运行脚本的环境变量](http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html)\n\n[业务代码如何判断生产/开发环境](http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html)        \n\n[DefinePlugin中的淫技巧](http://blog.csdn.net/sinat_17775997/article/details/70140322)\n\n<!-- more -->        \n\n### process.env\nprocess对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。\n\nprocess.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：\n\n    console.log(process.env);\n    console.log('username: ' + process.env.USERNAME);\n    console.log('PATH: ' + process.env.PATH);\n\n### webpack 开发和生产的区别\n开发环境(development)和生产环境(production)的构建目标差异很大。\n\n在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。\n\n而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。\n\n由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。\n\n分别为\n\nwebpack.config.js\n\nwebpack.dev.js\n\nwebpack.production.js\n\n### 如何区分生产环境还是开发环境\n引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.\n\n在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.\n    \n        // webpack.base.config.js\n        output: {\n            path: config.build.assetsRoot,\n            filename: '[name].js',\n            publicPath: process.env.NODE_ENV === 'production'\n              ? config.build.assetsPublicPath\n              : config.dev.assetsPublicPath\n          },\n \n      \n###  process.env.NODE_ENV如何设置 \n\n1. 因为process是nodejs全局变量,可以通过命令行设置\n        \n        \n        export NODE_ENV = production && webpack\n        \n        export NODE_ENV = dev && webpack\n        \n2. 也可以通过package.json设置\n        \n        \n            {\n              \"scripts\": {\n                \"dev\": \"export NODE_ENV=dev&&webpack  --progress --colors\",\n                \"production\": \"export NODE_ENV=production&&webpack  --progress --colors\",\n              },\n\n3. 也可以借助webpack.DefinePlugin插件,在代码里面设置,如\n          \n             \n                //webpack.dev.js\n             plugins: [\n                new webpack.DefinePlugin({\n                  'process.env': config.dev.env\n                }),\n             \n             //config/index.js\n             dev: {\n                 env: require('./dev.env'),\n                 port: 8080,\n    \n            //config/dev.env.js\n            var merge = require('webpack-merge')\n            var prodEnv = require('./prod.env')\n            \n            module.exports = merge(prodEnv, {\n              NODE_ENV: '\"development\"'\n            })\n\n但是在build.js中  process.env.NODE_ENV = 'production'  ,不知道这个和webpack.prod.js里面的有什么区别.\n     ","slug":"vue-cli中process-env-NODE-ENV","published":1,"updated":"2017-10-08T10:34:31.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8w00086ww35fnk24lk","content":"<p>看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><p>通过看了不同的文章,大概有所了解.</p>\n<p>请参考<a href=\"http://cnodejs.org/topic/57a409657a922d6f358cd22d\" target=\"_blank\" rel=\"external\">process.env</a></p>\n<p><a href=\"http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html\" target=\"_blank\" rel=\"external\">改变运行脚本的环境变量</a></p>\n<p><a href=\"http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html\" target=\"_blank\" rel=\"external\">业务代码如何判断生产/开发环境</a>        </p>\n<p><a href=\"http://blog.csdn.net/sinat_17775997/article/details/70140322\" target=\"_blank\" rel=\"external\">DefinePlugin中的淫技巧</a></p>\n<a id=\"more\"></a>        \n<h3 id=\"process-env\"><a href=\"#process-env\" class=\"headerlink\" title=\"process.env\"></a>process.env</h3><p>process对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。</p>\n<p>process.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：</p>\n<pre><code>console.log(process.env);\nconsole.log(&apos;username: &apos; + process.env.USERNAME);\nconsole.log(&apos;PATH: &apos; + process.env.PATH);\n</code></pre><h3 id=\"webpack-开发和生产的区别\"><a href=\"#webpack-开发和生产的区别\" class=\"headerlink\" title=\"webpack 开发和生产的区别\"></a>webpack 开发和生产的区别</h3><p>开发环境(development)和生产环境(production)的构建目标差异很大。</p>\n<p>在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。</p>\n<p>而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。</p>\n<p>由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p>\n<p>分别为</p>\n<p>webpack.config.js</p>\n<p>webpack.dev.js</p>\n<p>webpack.production.js</p>\n<h3 id=\"如何区分生产环境还是开发环境\"><a href=\"#如何区分生产环境还是开发环境\" class=\"headerlink\" title=\"如何区分生产环境还是开发环境\"></a>如何区分生产环境还是开发环境</h3><p>引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.</p>\n<p>在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><h3 id=\"process-env-NODE-ENV如何设置\"><a href=\"#process-env-NODE-ENV如何设置\" class=\"headerlink\" title=\"process.env.NODE_ENV如何设置\"></a>process.env.NODE_ENV如何设置</h3><ol>\n<li>因为process是nodejs全局变量,可以通过命令行设置</li>\n</ol>\n<pre><code>export NODE_ENV = production &amp;&amp; webpack\n\nexport NODE_ENV = dev &amp;&amp; webpack\n</code></pre><ol>\n<li>也可以通过package.json设置</li>\n</ol>\n<pre><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;export NODE_ENV=dev&amp;&amp;webpack  --progress --colors&quot;,\n    &quot;production&quot;: &quot;export NODE_ENV=production&amp;&amp;webpack  --progress --colors&quot;,\n  },\n</code></pre><ol>\n<li>也可以借助webpack.DefinePlugin插件,在代码里面设置,如</li>\n</ol>\n<pre><code>    //webpack.dev.js\n plugins: [\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n\n //config/index.js\n dev: {\n     env: require(&apos;./dev.env&apos;),\n     port: 8080,\n\n//config/dev.env.js\nvar merge = require(&apos;webpack-merge&apos;)\nvar prodEnv = require(&apos;./prod.env&apos;)\n\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: &apos;&quot;development&quot;&apos;\n})\n</code></pre><p>但是在build.js中  process.env.NODE_ENV = ‘production’  ,不知道这个和webpack.prod.js里面的有什么区别.</p>\n","site":{"data":{}},"excerpt":"<p>看前面vue-cli讲解的文章,对process.env.NODE_ENV,一直不理解是怎么设置的,怎么就变成production或者development</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><p>通过看了不同的文章,大概有所了解.</p>\n<p>请参考<a href=\"http://cnodejs.org/topic/57a409657a922d6f358cd22d\" target=\"_blank\" rel=\"external\">process.env</a></p>\n<p><a href=\"http://blog.404mzk.com/%E5%8C%BA%E5%88%86%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.html\" target=\"_blank\" rel=\"external\">改变运行脚本的环境变量</a></p>\n<p><a href=\"http://array_huang.coding.me/webpack-book/chapter2/webpack-dev-production-environment.html\" target=\"_blank\" rel=\"external\">业务代码如何判断生产/开发环境</a>        </p>\n<p><a href=\"http://blog.csdn.net/sinat_17775997/article/details/70140322\" target=\"_blank\" rel=\"external\">DefinePlugin中的淫技巧</a></p>","more":"<h3 id=\"process-env\"><a href=\"#process-env\" class=\"headerlink\" title=\"process.env\"></a>process.env</h3><p>process对象用于处理与当前进程相关的事情，它是一个全局对象，可以在任何地方直接访问到它而无需引入额外模块。 它是 EventEmitter 的一个实例。</p>\n<p>process.env 获取当前系统环境信息的对象，常规可以用来进一步获取环境变量、用户名等系统信息：</p>\n<pre><code>console.log(process.env);\nconsole.log(&apos;username: &apos; + process.env.USERNAME);\nconsole.log(&apos;PATH: &apos; + process.env.PATH);\n</code></pre><h3 id=\"webpack-开发和生产的区别\"><a href=\"#webpack-开发和生产的区别\" class=\"headerlink\" title=\"webpack 开发和生产的区别\"></a>webpack 开发和生产的区别</h3><p>开发环境(development)和生产环境(production)的构建目标差异很大。</p>\n<p>在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。</p>\n<p>而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。</p>\n<p>由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p>\n<p>分别为</p>\n<p>webpack.config.js</p>\n<p>webpack.dev.js</p>\n<p>webpack.production.js</p>\n<h3 id=\"如何区分生产环境还是开发环境\"><a href=\"#如何区分生产环境还是开发环境\" class=\"headerlink\" title=\"如何区分生产环境还是开发环境\"></a>如何区分生产环境还是开发环境</h3><p>引入process.env，这样就可以在业务代码中靠process.env.NODE_ENV来判断.</p>\n<p>在webpack.base.config.js区分process.env.NODE_ENV来决定设置webpack配置为开发还是生产.</p>\n<pre><code>// webpack.base.config.js\noutput: {\n    path: config.build.assetsRoot,\n    filename: &apos;[name].js&apos;,\n    publicPath: process.env.NODE_ENV === &apos;production&apos;\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n</code></pre><h3 id=\"process-env-NODE-ENV如何设置\"><a href=\"#process-env-NODE-ENV如何设置\" class=\"headerlink\" title=\"process.env.NODE_ENV如何设置\"></a>process.env.NODE_ENV如何设置</h3><ol>\n<li>因为process是nodejs全局变量,可以通过命令行设置</li>\n</ol>\n<pre><code>export NODE_ENV = production &amp;&amp; webpack\n\nexport NODE_ENV = dev &amp;&amp; webpack\n</code></pre><ol>\n<li>也可以通过package.json设置</li>\n</ol>\n<pre><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;export NODE_ENV=dev&amp;&amp;webpack  --progress --colors&quot;,\n    &quot;production&quot;: &quot;export NODE_ENV=production&amp;&amp;webpack  --progress --colors&quot;,\n  },\n</code></pre><ol>\n<li>也可以借助webpack.DefinePlugin插件,在代码里面设置,如</li>\n</ol>\n<pre><code>    //webpack.dev.js\n plugins: [\n    new webpack.DefinePlugin({\n      &apos;process.env&apos;: config.dev.env\n    }),\n\n //config/index.js\n dev: {\n     env: require(&apos;./dev.env&apos;),\n     port: 8080,\n\n//config/dev.env.js\nvar merge = require(&apos;webpack-merge&apos;)\nvar prodEnv = require(&apos;./prod.env&apos;)\n\nmodule.exports = merge(prodEnv, {\n  NODE_ENV: &apos;&quot;development&quot;&apos;\n})\n</code></pre><p>但是在build.js中  process.env.NODE_ENV = ‘production’  ,不知道这个和webpack.prod.js里面的有什么区别.</p>"},{"title":"webpack总结(一)","date":"2017-10-07T04:24:53.000Z","_content":"# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","source":"_posts/webpack总结-一.md","raw":"---\ntitle: webpack总结(一)\ndate: 2017-10-07 12:24:53\ntags:\n    -webpack\n---\n# 前言\n\n作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.\n\nvue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.\n\n但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.\n\n# webpack特点\n\n是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.\n\nwebpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.\n\n两个特点:\n1. 一切皆模块\n\n2. 按需加载\n\n# webpack基本配置\n\n可以子命令行执行  webpack .........来打包\n\n一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.\n\n实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.\n\n\n    const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm\n    const webpack = require('webpack'); //to access built-in plugins\n    const path = require('path');\n    \n    const config = {\n      entry: './path/to/my/entry/file.js',\n      output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'my-first-webpack.bundle.js'\n      },\n      module: {\n        rules: [\n          {test: /\\.(js|jsx)$/, loader: 'babel-loader'}\n        ]\n      },\n      plugins: [\n        new webpack.optimize.UglifyJsPlugin(),\n        new HtmlWebpackPlugin({template: './src/index.html'})\n      ]\n    };\n    \n    module.exports = config;\n\n这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader->rules等等,可能下面的会有所冲突)\n<!-- more -->\n## 生成source Maps(调试用)\n需要在配置中设置\ndevtool:'source-map'  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)\n    \n## 构建本地服务器\n只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.\n而且webpack也是基于nodejs的.\n\n1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.\n\n2.在配置中\n    \n        devServer:{\n            contentBase:'./dist',\n            colors:true,\n            historyApiFallback:true,\n            inline:true\n        }\n\n## loaders \n   通过不同的loader,对各种文件进行处理\n   1. 安装\n   2. 在配置的modules属性下进行配置\n           \n            \n      module: {\n          rules: [\n            {\n              test: /\\.(js|vue)$/,\n              loader: 'eslint-loader',\n              enforce: 'pre',\n              include: [resolve('src'), resolve('test')],\n              options: {\n                formatter: require('eslint-friendly-formatter')\n              }\n            },\n            {\n              test: /\\.vue$/,\n              loader: 'vue-loader',\n              options: vueLoaderConfig\n            },\n            {\n              test: /\\.js$/,\n              loader: 'babel-loader',\n              include: [resolve('src'), resolve('test')]\n            },\n            {\n              test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('img/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('media/[name].[hash:7].[ext]')\n              }\n            },\n            {\n              test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n              loader: 'url-loader',\n              options: {\n                limit: 10000,\n                name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n              }\n            }\n          ]\n        }\n            \n   必选属性:\n   \n   test: 匹配要处理的文件扩展名(正则表达式)\n   \n   loader而: 加载器\n   \n   可选属性:\n   \n   include: 手动添加必须处理的文件(文件夹)\n   exclude: 手动屏蔽不需要处理的文件(文件夹)\n      \n   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)\n   \n   \n        {test:/\\.png|jpe?g|ico$/,\n         loader:'url-loader',\n         exclude:'/node-modles/',(举例而已,实际没有)\n         query:{\n            limited:10000,\n            name: '[name].[ext]?[hash]'\n         }\n        }\n        \n        \n## bable \n将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中\n用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react\n配置如下:\n  \n  \n      loaders:[{\n        test:/\\.js$/,\n        exclude:'/node_modules',\n        laoder:'babel',\n        query:{\n            presets:['es2015','react']\n        }\n      }]\n      \nbable还有非常的配置选项,实际一般把配置选项放到'bablerc'这个单独的文件中,webpack会自动调用.","slug":"webpack总结-一","published":1,"updated":"2017-10-07T08:20:25.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp8w00096ww3yvto7nx5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br><a id=\"more\"></a></p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个前端开发者,现在已经不可避免的要和webpack打交道了,尤其使用vuejs以后,项目上不可避免要使用集成webpack的vue-cli.</p>\n<p>vue-cli基本上已经配置好了相关的webpack配置,基本上就可以开发了,不用开发人员再配置webpack,省时省力.</p>\n<p>但是webpack还是要弄清除基本的配置,尤其在面试的时候不可避免被问到,我在网上看到好多讲解的文章,受益匪浅,但是总是看时明白,过两天就忘记了,望而复始,所以想总结一下,以便能有个地方可以随时查阅,下面会引用别人的文章,以及自己的理解,肯定会有错误之处,请多对比.</p>\n<h1 id=\"webpack特点\"><a href=\"#webpack特点\" class=\"headerlink\" title=\"webpack特点\"></a>webpack特点</h1><p>是一个模块打包工具,不同于gulp,gulp只是一个构建工具,只执行相应的任务,比如说压缩/合并/检查/自动刷新等等,替代了人工操作,提高了开发人员的工作效率而已,不会对项目结构有所影响.</p>\n<p>webpack会把js/css/image/html等文件都视作模块,根据模块依赖关系进行静态分析,然后将这些模块按照指定的规则生成对应的静态资源.不仅仅可以执行压缩/合并等任务,还会深度参与项目结构.而且可以根据需求生成多个打包js,可以异步加载,实现按需加载.</p>\n<p>两个特点:</p>\n<ol>\n<li><p>一切皆模块</p>\n</li>\n<li><p>按需加载</p>\n</li>\n</ol>\n<h1 id=\"webpack基本配置\"><a href=\"#webpack基本配置\" class=\"headerlink\" title=\"webpack基本配置\"></a>webpack基本配置</h1><p>可以子命令行执行  webpack ………来打包</p>\n<p>一般专门配置webpack.config.js来方便的只在命令行执行webpack来打包.</p>\n<p>实际开发中一般又分成webpack.dev.config.js和webpack.build.config.js,还可能有webpack.test.config.js.具体可以参考vue-cli,后面在具体讲解.</p>\n<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //installed via npm\nconst webpack = require(&apos;webpack&apos;); //to access built-in plugins\nconst path = require(&apos;path&apos;);\n\nconst config = {\n  entry: &apos;./path/to/my/entry/file.js&apos;,\n  output: {\n    path: path.resolve(__dirname, &apos;dist&apos;),\n    filename: &apos;my-first-webpack.bundle.js&apos;\n  },\n  module: {\n    rules: [\n      {test: /\\.(js|jsx)$/, loader: &apos;babel-loader&apos;}\n    ]\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin(),\n    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})\n  ]\n};\n\nmodule.exports = config;\n</code></pre><p>这是一个简单的示例,还有其他配置选项,下面一个一个来介绍.(因为webpack2配置方面有点改变比如,loader-&gt;rules等等,可能下面的会有所冲突)<br>","more":"</p>\n<h2 id=\"生成source-Maps-调试用\"><a href=\"#生成source-Maps-调试用\" class=\"headerlink\" title=\"生成source Maps(调试用)\"></a>生成source Maps(调试用)</h2><p>需要在配置中设置<br>devtool:’source-map’  (总共有七个选项,不同选项,打包速度也快,但也越不利于调试,调试也是各坑,有的选项打不上断点或者断点在下一行)</p>\n<h2 id=\"构建本地服务器\"><a href=\"#构建本地服务器\" class=\"headerlink\" title=\"构建本地服务器\"></a>构建本地服务器</h2><p>只从有了nodejs以后,前端就可以用node在本地起服务,而不用在配置java服务.<br>而且webpack也是基于nodejs的.</p>\n<p>1.npm 安装webpack-dev-server,这是一个基于express的webpack服务.</p>\n<p>2.在配置中</p>\n<pre><code>devServer:{\n    contentBase:&apos;./dist&apos;,\n    colors:true,\n    historyApiFallback:true,\n    inline:true\n}\n</code></pre><h2 id=\"loaders\"><a href=\"#loaders\" class=\"headerlink\" title=\"loaders\"></a>loaders</h2><p>   通过不同的loader,对各种文件进行处理</p>\n<ol>\n<li>安装</li>\n<li>在配置的modules属性下进行配置</li>\n</ol>\n<pre><code>module: {\n    rules: [\n      {\n        test: /\\.(js|vue)$/,\n        loader: &apos;eslint-loader&apos;,\n        enforce: &apos;pre&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],\n        options: {\n          formatter: require(&apos;eslint-friendly-formatter&apos;)\n        }\n      },\n      {\n        test: /\\.vue$/,\n        loader: &apos;vue-loader&apos;,\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: &apos;babel-loader&apos;,\n        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: &apos;url-loader&apos;,\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)\n        }\n      }\n    ]\n  }\n</code></pre><p>   必选属性:</p>\n<p>   test: 匹配要处理的文件扩展名(正则表达式)</p>\n<p>   loader而: 加载器</p>\n<p>   可选属性:</p>\n<p>   include: 手动添加必须处理的文件(文件夹)<br>   exclude: 手动屏蔽不需要处理的文件(文件夹)</p>\n<p>   query: 提供额外的处置选项,也可以直接写在loader里(webpack2应该是改成options,如上面的配置)</p>\n<pre><code>{test:/\\.png|jpe?g|ico$/,\n loader:&apos;url-loader&apos;,\n exclude:&apos;/node-modles/&apos;,(举例而已,实际没有)\n query:{\n    limited:10000,\n    name: &apos;[name].[ext]?[hash]&apos;\n }\n}\n</code></pre><h2 id=\"bable\"><a href=\"#bable\" class=\"headerlink\" title=\"bable\"></a>bable</h2><p>将ES6转化为ES5的包,会有好几个包,核心功能在bable-core这个包中<br>用的最多的是解析ES6的babel-prsent-es2015和解析jsx的bable-present-react<br>配置如下:</p>\n<pre><code>loaders:[{\n  test:/\\.js$/,\n  exclude:&apos;/node_modules&apos;,\n  laoder:&apos;babel&apos;,\n  query:{\n      presets:[&apos;es2015&apos;,&apos;react&apos;]\n  }\n}]\n</code></pre><p>bable还有非常的配置选项,实际一般把配置选项放到’bablerc’这个单独的文件中,webpack会自动调用.</p>"},{"title":"vue-cli编译打包后起node服务测试","date":"2017-10-08T06:37:32.000Z","_content":"使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.\n\n项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.\n\n但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.\n\n### 原因\n因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.\n\n### 解决1 修改配置\n如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.\n<!-- more -->        \n\n       这里有一个万能解决办法：\n           1. 将config/index.js 里面的 assetsPublicPath:'/' 改为assetsPublicPath:'./'  \n           2. build/util.js里面的\n           if (options.extract) {\n                     return ExtractTextPlugin.extract({\n                                   use: loaders,\n                                   fallback: 'vue-style-loader',\n                                   publicPath:'/'\n           })\n           将其中的publicPath改为：publicPath：'../../'就可以了。这样打包出来的路径就是正确的了。\n       \n           第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n           第二种是为了改变vue文件中使用style样式里面例如background:url('xxx')，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n\n\n### 解决2 起一个node服务,并定位静态资源入口\n1.新建build/prod-server.js\n    \n    var express = require('express')\n    \n    var app = express()\n    var opn = require('opn')\n    var path = require('path')\n    \n    var distPath = path.join(__dirname,\"../dist\");\n    //静态资源目录入口\n    app.use(express.static(distPath));\n    \n    module.exports = app.listen(8081, function (err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        var uri = 'http://localhost:' + 8081+\"/\"\n        console.log('Listening at ' + uri + '\\n')\n        opn(uri)\n    })\n\n直接在项目目录命令行运行 node  prod-server.js  就可以访问了\n\n2 也可以在package.json中设置\n\n        \"scripts\": {\n            \"dev\": \"node build/dev-server.js\",\n            \"build\": \"node build/build.js\",\n            \"local-server\": \"node build/prod-server.js\"\n          },\n          \n这样也可以直接  npm run local-server             ","source":"_posts/vue-cli编译打包后起node服务测试.md","raw":"---\ntitle: vue-cli编译打包后起node服务测试\ndate: 2017-10-08 14:37:32\ntags:\n    - vue-cli\n    - node\n    - vue\n    - webpack\n---\n使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.\n\n项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.\n\n但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.\n\n### 原因\n因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.\n\n### 解决1 修改配置\n如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.\n<!-- more -->        \n\n       这里有一个万能解决办法：\n           1. 将config/index.js 里面的 assetsPublicPath:'/' 改为assetsPublicPath:'./'  \n           2. build/util.js里面的\n           if (options.extract) {\n                     return ExtractTextPlugin.extract({\n                                   use: loaders,\n                                   fallback: 'vue-style-loader',\n                                   publicPath:'/'\n           })\n           将其中的publicPath改为：publicPath：'../../'就可以了。这样打包出来的路径就是正确的了。\n       \n           第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n           第二种是为了改变vue文件中使用style样式里面例如background:url('xxx')，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n\n\n### 解决2 起一个node服务,并定位静态资源入口\n1.新建build/prod-server.js\n    \n    var express = require('express')\n    \n    var app = express()\n    var opn = require('opn')\n    var path = require('path')\n    \n    var distPath = path.join(__dirname,\"../dist\");\n    //静态资源目录入口\n    app.use(express.static(distPath));\n    \n    module.exports = app.listen(8081, function (err) {\n        if (err) {\n            console.log(err)\n            return\n        }\n        var uri = 'http://localhost:' + 8081+\"/\"\n        console.log('Listening at ' + uri + '\\n')\n        opn(uri)\n    })\n\n直接在项目目录命令行运行 node  prod-server.js  就可以访问了\n\n2 也可以在package.json中设置\n\n        \"scripts\": {\n            \"dev\": \"node build/dev-server.js\",\n            \"build\": \"node build/build.js\",\n            \"local-server\": \"node build/prod-server.js\"\n          },\n          \n这样也可以直接  npm run local-server             ","slug":"vue-cli编译打包后起node服务测试","published":1,"updated":"2017-10-08T07:16:23.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp9c000b6ww3nzcha2o2","content":"<p>使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.</p>\n<p>项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.</p>\n<p>但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.</p>\n<h3 id=\"解决1-修改配置\"><a href=\"#解决1-修改配置\" class=\"headerlink\" title=\"解决1 修改配置\"></a>解决1 修改配置</h3><p>如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.<br><a id=\"more\"></a>        </p>\n<pre><code>这里有一个万能解决办法：\n    1. 将config/index.js 里面的 assetsPublicPath:&apos;/&apos; 改为assetsPublicPath:&apos;./&apos;  \n    2. build/util.js里面的\n    if (options.extract) {\n              return ExtractTextPlugin.extract({\n                            use: loaders,\n                            fallback: &apos;vue-style-loader&apos;,\n                            publicPath:&apos;/&apos;\n    })\n    将其中的publicPath改为：publicPath：&apos;../../&apos;就可以了。这样打包出来的路径就是正确的了。\n\n    第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n    第二种是为了改变vue文件中使用style样式里面例如background:url(&apos;xxx&apos;)，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n</code></pre><h3 id=\"解决2-起一个node服务-并定位静态资源入口\"><a href=\"#解决2-起一个node服务-并定位静态资源入口\" class=\"headerlink\" title=\"解决2 起一个node服务,并定位静态资源入口\"></a>解决2 起一个node服务,并定位静态资源入口</h3><p>1.新建build/prod-server.js</p>\n<pre><code>var express = require(&apos;express&apos;)\n\nvar app = express()\nvar opn = require(&apos;opn&apos;)\nvar path = require(&apos;path&apos;)\n\nvar distPath = path.join(__dirname,&quot;../dist&quot;);\n//静态资源目录入口\napp.use(express.static(distPath));\n\nmodule.exports = app.listen(8081, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    var uri = &apos;http://localhost:&apos; + 8081+&quot;/&quot;\n    console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n    opn(uri)\n})\n</code></pre><p>直接在项目目录命令行运行 node  prod-server.js  就可以访问了</p>\n<p>2 也可以在package.json中设置</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;local-server&quot;: &quot;node build/prod-server.js&quot;\n  },\n</code></pre><p>这样也可以直接  npm run local-server             </p>\n","site":{"data":{}},"excerpt":"<p>使用vue-cli开发项目中,一直使用dev-server.js这个本地服务,实现从内存中读取文件.</p>\n<p>项目完成后,要编译打包生成打包文件,提示不能通过打开file//方式访问,需要另外起服务访问.</p>\n<p>但是打包好后,不可能立即放到真实服务器中,还需要通过在本地测试一下,故另开一个node服务.</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为打包后生成的文件如script/link等路径都是绝对路径,当然找不到了.</p>\n<h3 id=\"解决1-修改配置\"><a href=\"#解决1-修改配置\" class=\"headerlink\" title=\"解决1 修改配置\"></a>解决1 修改配置</h3><p>如果弄明白vue-cli中webpack的配置,下面这个肯定明白,就是把绝对路径形式改成相对路径,但是不知道对放到真实服务器上有没影响.<br>","more":"</p>\n<pre><code>这里有一个万能解决办法：\n    1. 将config/index.js 里面的 assetsPublicPath:&apos;/&apos; 改为assetsPublicPath:&apos;./&apos;  \n    2. build/util.js里面的\n    if (options.extract) {\n              return ExtractTextPlugin.extract({\n                            use: loaders,\n                            fallback: &apos;vue-style-loader&apos;,\n                            publicPath:&apos;/&apos;\n    })\n    将其中的publicPath改为：publicPath：&apos;../../&apos;就可以了。这样打包出来的路径就是正确的了。\n\n    第一个是为了改变js中引入图片的路径，改为./ 就是指在当前路径，这个.代表的路径就是assetsRoot+assetsSubDictionary，我这里定位到dist/static/ ，加上图片前缀img，就可以找到了。\n    第二种是为了改变vue文件中使用style样式里面例如background:url(&apos;xxx&apos;)，这样的路径，因为style最终变成css文件在dist/static/css里面，我们的图片放在dist/static/img中，那么加上../../变成dist目录下，默认的目录前缀是static，img是图片默认前缀，这样就可以定位到图片。\n</code></pre><h3 id=\"解决2-起一个node服务-并定位静态资源入口\"><a href=\"#解决2-起一个node服务-并定位静态资源入口\" class=\"headerlink\" title=\"解决2 起一个node服务,并定位静态资源入口\"></a>解决2 起一个node服务,并定位静态资源入口</h3><p>1.新建build/prod-server.js</p>\n<pre><code>var express = require(&apos;express&apos;)\n\nvar app = express()\nvar opn = require(&apos;opn&apos;)\nvar path = require(&apos;path&apos;)\n\nvar distPath = path.join(__dirname,&quot;../dist&quot;);\n//静态资源目录入口\napp.use(express.static(distPath));\n\nmodule.exports = app.listen(8081, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    var uri = &apos;http://localhost:&apos; + 8081+&quot;/&quot;\n    console.log(&apos;Listening at &apos; + uri + &apos;\\n&apos;)\n    opn(uri)\n})\n</code></pre><p>直接在项目目录命令行运行 node  prod-server.js  就可以访问了</p>\n<p>2 也可以在package.json中设置</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,\n    &quot;build&quot;: &quot;node build/build.js&quot;,\n    &quot;local-server&quot;: &quot;node build/prod-server.js&quot;\n  },\n</code></pre><p>这样也可以直接  npm run local-server             </p>"},{"title":"使用代理解决跨域限制","date":"2017-10-06T13:00:53.000Z","_content":"# 问题\n1. 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n# 代理\n1.\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n\n\n2.\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n\n3.\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n","source":"_posts/使用代理解决跨域限制.md","raw":"---\ntitle: 使用代理解决跨域限制\ndate: 2017-10-06 21:00:53\ntags:\n    -跨域\n    -代理\n---\n# 问题\n1. 在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.\n\n# 代理\n1.\n    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.\n\n\n2.\n    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.\n\n        import axios from 'axios',\n        let url = '/api/getData',\n        let data = {....},\n        axios.get(url, {\n            params: data\n        }).then((res) => {\n          ...........................\n          })\n\n\n3.\n    在本地node服务中对请求'/api/getData'做代理,发请求到实际的接口\n\n        var axios = require('axios')\n        var app = express()\n        var apiRoutes = express.Router()\n\n        apiRoutes.get('/getData', function (req, res) {\n            //实际接口\n          var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'\n          //修改请求头信息\n          axios.get(url, {\n            headers: {\n              referer: 'https://c.y.qq.com/',\n              host: 'c.y.qq.com'\n            },\n            params: req.query\n          }).then((response) => {\n            res.json(response.data)\n          }).catch((e) => {\n            console.log(e)\n          })\n        })\n\n        app.use('/api', apiRoutes)\n","slug":"使用代理解决跨域限制","published":1,"updated":"2017-10-06T13:57:41.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp9r000x6ww3n3clqjg4","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</li>\n</ol>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>1.<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.</p>\n<p>2.<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3.<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>在跨域请求(经常是在用到别人的接口时)会遇到一些限制,对方会检查http请求携带的来源,比如检查host,referer等.</li>\n</ol>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p>1.<br>    我们可以在本地起一个node服务,比如vue开发中的dev-server,使用其发http请求,通过修该请求信息,能够被对方接口通过返回数据,又因为同源策略是浏览器安全的范畴,所以在node上不用考虑跨域问题.</p>\n<p>2.<br>    项目中只需发一个ajax请求(因为向本地node服务发,故同源,不用考虑跨域).vue中使用axios作为ajax工具,其既可以在浏览器中使用,也可以在node中使用.</p>\n<pre><code>import axios from &apos;axios&apos;,\nlet url = &apos;/api/getData&apos;,\nlet data = {....},\naxios.get(url, {\n    params: data\n}).then((res) =&gt; {\n  ...........................\n  })\n</code></pre><p>3.<br>    在本地node服务中对请求’/api/getData’做代理,发请求到实际的接口</p>\n<pre><code>var axios = require(&apos;axios&apos;)\nvar app = express()\nvar apiRoutes = express.Router()\n\napiRoutes.get(&apos;/getData&apos;, function (req, res) {\n    //实际接口\n  var url = &apos;https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&apos;\n  //修改请求头信息\n  axios.get(url, {\n    headers: {\n      referer: &apos;https://c.y.qq.com/&apos;,\n      host: &apos;c.y.qq.com&apos;\n    },\n    params: req.query\n  }).then((response) =&gt; {\n    res.json(response.data)\n  }).catch((e) =&gt; {\n    console.log(e)\n  })\n})\n\napp.use(&apos;/api&apos;, apiRoutes)\n</code></pre>"},{"title":"webpack总结二","date":"2017-10-07T08:41:33.000Z","_content":"### css\nwebpack提供了两个工具处理样式表 --> css-loader 和 style-loader\ncss-loader 可以使用类似@import或url(...)的方法实现require的功能\nstyle-loader将所有计算后的样式加入到页面中\n两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)\n    \n    {test:/\\.css$/,\n    loader:'style!css'  \n    //也可以写成\n    loader:['style','css']\n    }\n<!-- more -->\n\n### css预处理\n比如 less-loader/sass-loader/sylus-loader\n以less为例\n\n先npm i less-loader  --dev\n    \n    \n    {\n            test: /\\.(less|css)$/,\n            use:[ 'style-loader','css-loader','less-loader'],\n    },\n    \n    \n### postcss  \n有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器\n 先安装postcss-loader 和 依赖的插件autoprefixer\n 在配置中(webpack2中配置方式好像变化了,注意)\n \n    module: {\n            rules: [\n              {test: /\\.css$/, loader: 'style!css!postcss'}\n            ]\n          },\n    postcss: [require('autoprefixer')]  //声明依赖的插件   \n\n    \n### entry(入口)\n可以是字符串,数组,对象\n1. 只有一个入口\n2. 添加彼此互不依赖文件用数组,如['./xx/a.js', './xx/b.js'],\n最后打包时会在bundle.js后面添加b.js\n3. 如果是多页面应用(非spa),则为每个页面生成一个bundle文件,\n\n\n    entry:{\n            'indexEntry' : './src/index,js',\n            'pageAEntry' : './src/pageA.js'\n           },\n    output:{\n            path:'./dist',\n            filename:'[name].js' //name取自entry的属性键名\n          }  \n           \n\n            \n### output(输出)            \n两个选项\n\n    \n    output: {\n            path: './dist',   //webpack打包后文件存放位置\n            publicPath: 'http://cdn...'  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n            }","source":"_posts/webpack总结二.md","raw":"---\ntitle: webpack总结二\ndate: 2017-10-07 16:41:33\ntags:\n    -webpack\n---\n### css\nwebpack提供了两个工具处理样式表 --> css-loader 和 style-loader\ncss-loader 可以使用类似@import或url(...)的方法实现require的功能\nstyle-loader将所有计算后的样式加入到页面中\n两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)\n    \n    {test:/\\.css$/,\n    loader:'style!css'  \n    //也可以写成\n    loader:['style','css']\n    }\n<!-- more -->\n\n### css预处理\n比如 less-loader/sass-loader/sylus-loader\n以less为例\n\n先npm i less-loader  --dev\n    \n    \n    {\n            test: /\\.(less|css)$/,\n            use:[ 'style-loader','css-loader','less-loader'],\n    },\n    \n    \n### postcss  \n有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器\n 先安装postcss-loader 和 依赖的插件autoprefixer\n 在配置中(webpack2中配置方式好像变化了,注意)\n \n    module: {\n            rules: [\n              {test: /\\.css$/, loader: 'style!css!postcss'}\n            ]\n          },\n    postcss: [require('autoprefixer')]  //声明依赖的插件   \n\n    \n### entry(入口)\n可以是字符串,数组,对象\n1. 只有一个入口\n2. 添加彼此互不依赖文件用数组,如['./xx/a.js', './xx/b.js'],\n最后打包时会在bundle.js后面添加b.js\n3. 如果是多页面应用(非spa),则为每个页面生成一个bundle文件,\n\n\n    entry:{\n            'indexEntry' : './src/index,js',\n            'pageAEntry' : './src/pageA.js'\n           },\n    output:{\n            path:'./dist',\n            filename:'[name].js' //name取自entry的属性键名\n          }  \n           \n\n            \n### output(输出)            \n两个选项\n\n    \n    output: {\n            path: './dist',   //webpack打包后文件存放位置\n            publicPath: 'http://cdn...'  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n            }","slug":"webpack总结二","published":1,"updated":"2017-10-07T09:43:25.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cp9r000y6ww3rvih09fn","content":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>webpack提供了两个工具处理样式表 –&gt; css-loader 和 style-loader<br>css-loader 可以使用类似@import或url(…)的方法实现require的功能<br>style-loader将所有计算后的样式加入到页面中<br>两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)</p>\n<pre><code>{test:/\\.css$/,\nloader:&apos;style!css&apos;  \n//也可以写成\nloader:[&apos;style&apos;,&apos;css&apos;]\n}\n</code></pre><a id=\"more\"></a>\n<h3 id=\"css预处理\"><a href=\"#css预处理\" class=\"headerlink\" title=\"css预处理\"></a>css预处理</h3><p>比如 less-loader/sass-loader/sylus-loader<br>以less为例</p>\n<p>先npm i less-loader  –dev</p>\n<pre><code>{\n        test: /\\.(less|css)$/,\n        use:[ &apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;],\n},\n</code></pre><h3 id=\"postcss\"><a href=\"#postcss\" class=\"headerlink\" title=\"postcss\"></a>postcss</h3><p>有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器<br> 先安装postcss-loader 和 依赖的插件autoprefixer<br> 在配置中(webpack2中配置方式好像变化了,注意)</p>\n<pre><code>module: {\n        rules: [\n          {test: /\\.css$/, loader: &apos;style!css!postcss&apos;}\n        ]\n      },\npostcss: [require(&apos;autoprefixer&apos;)]  //声明依赖的插件   \n</code></pre><h3 id=\"entry-入口\"><a href=\"#entry-入口\" class=\"headerlink\" title=\"entry(入口)\"></a>entry(入口)</h3><p>可以是字符串,数组,对象</p>\n<ol>\n<li>只有一个入口</li>\n<li>添加彼此互不依赖文件用数组,如[‘./xx/a.js’, ‘./xx/b.js’],<br>最后打包时会在bundle.js后面添加b.js</li>\n<li>如果是多页面应用(非spa),则为每个页面生成一个bundle文件,</li>\n</ol>\n<pre><code>entry:{\n        &apos;indexEntry&apos; : &apos;./src/index,js&apos;,\n        &apos;pageAEntry&apos; : &apos;./src/pageA.js&apos;\n       },\noutput:{\n        path:&apos;./dist&apos;,\n        filename:&apos;[name].js&apos; //name取自entry的属性键名\n      }  \n</code></pre><h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output(输出)\"></a>output(输出)</h3><p>两个选项</p>\n<pre><code>output: {\n        path: &apos;./dist&apos;,   //webpack打包后文件存放位置\n        publicPath: &apos;http://cdn...&apos;  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n        }\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><p>webpack提供了两个工具处理样式表 –&gt; css-loader 和 style-loader<br>css-loader 可以使用类似@import或url(…)的方法实现require的功能<br>style-loader将所有计算后的样式加入到页面中<br>两者缺一不可(多个加载器中间用!分割,从右向左执行,也可写成数组形式)</p>\n<pre><code>{test:/\\.css$/,\nloader:&apos;style!css&apos;  \n//也可以写成\nloader:[&apos;style&apos;,&apos;css&apos;]\n}\n</code></pre>","more":"<h3 id=\"css预处理\"><a href=\"#css预处理\" class=\"headerlink\" title=\"css预处理\"></a>css预处理</h3><p>比如 less-loader/sass-loader/sylus-loader<br>以less为例</p>\n<p>先npm i less-loader  –dev</p>\n<pre><code>{\n        test: /\\.(less|css)$/,\n        use:[ &apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;],\n},\n</code></pre><h3 id=\"postcss\"><a href=\"#postcss\" class=\"headerlink\" title=\"postcss\"></a>postcss</h3><p>有好几个功能,这里只介绍为css代码添加前缀来适应不同的浏览器<br> 先安装postcss-loader 和 依赖的插件autoprefixer<br> 在配置中(webpack2中配置方式好像变化了,注意)</p>\n<pre><code>module: {\n        rules: [\n          {test: /\\.css$/, loader: &apos;style!css!postcss&apos;}\n        ]\n      },\npostcss: [require(&apos;autoprefixer&apos;)]  //声明依赖的插件   \n</code></pre><h3 id=\"entry-入口\"><a href=\"#entry-入口\" class=\"headerlink\" title=\"entry(入口)\"></a>entry(入口)</h3><p>可以是字符串,数组,对象</p>\n<ol>\n<li>只有一个入口</li>\n<li>添加彼此互不依赖文件用数组,如[‘./xx/a.js’, ‘./xx/b.js’],<br>最后打包时会在bundle.js后面添加b.js</li>\n<li>如果是多页面应用(非spa),则为每个页面生成一个bundle文件,</li>\n</ol>\n<pre><code>entry:{\n        &apos;indexEntry&apos; : &apos;./src/index,js&apos;,\n        &apos;pageAEntry&apos; : &apos;./src/pageA.js&apos;\n       },\noutput:{\n        path:&apos;./dist&apos;,\n        filename:&apos;[name].js&apos; //name取自entry的属性键名\n      }  \n</code></pre><h3 id=\"output-输出\"><a href=\"#output-输出\" class=\"headerlink\" title=\"output(输出)\"></a>output(输出)</h3><p>两个选项</p>\n<pre><code>output: {\n        path: &apos;./dist&apos;,   //webpack打包后文件存放位置\n        publicPath: &apos;http://cdn...&apos;  //生产环境下  静态资源访问地址,比如要把打包后的文件放到cnd上,就可以配置这个选项\n        }\n</code></pre>"},{"title":"webpack总结三","date":"2017-10-07T13:05:18.000Z","_content":"\n## 插件\nwebpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能\n如果是第三方插件,需要先安装\n\n### HtmlWebpackPlugin\n自动生成html插件,自动在dist目录下自动生成一个index.html\n<!-- more -->\n    \n     //webpack.config.js\n      var HtmlWebpackPlugin = require('html-webpack-plugin');\n      module.exports={\n        entry:'./index.js',\n        output:{\n          path:__dirname+'/dist',\n          filename:'bundle.js'\n        }\n        plugins:[\n          new HtmlWebpackPlugin()\n        ]\n      }\n      \n更多的配置\n      \n       plugins: [\n          new HtmlWebpackPlugin({\n            title: 'My App',\n            filename: 'admin.html',\n            template:'header.html',\n            inject: 'body',\n            favicon:'./images/favico.ico',\n            minify:true,\n            hash:true,\n            cache:false,\n            showErrors:false,\n            \"chunks\": {\n            \"head\": {\n              \"entry\": \"assets/head_bundle.js\",\n              \"css\": [ \"main.css\" ]\n            },\n            xhtml:false\n          })\n        ]\n\n### extract-text-webpack-plugin\n提取样式插件\n\n        var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n        new ExtractTextPlugin(\"[name].[hash].css\")\n        \n                \n## 优化插件\n需要在生产打包时进行额外的处理,比如压缩js代码.\n就要用到内置插件UgilifyJsPugin\n    \n        plugins:[\n            new webpack.optimize.UglifJsPlugin()\n        ]\n        \n在生产打包会有更多处理,在vue-cli中有以下配置\n        \n        new webpack.optimize.CommonsChunkPlugin({\n              name: 'vendor',\n              minChunks: function (module, count) {\n                // any required modules inside node_modules are extracted to vendor\n                return (\n                  module.resource &&\n                  /\\.js$/.test(module.resource) &&\n                  module.resource.indexOf(\n                    path.join(__dirname, '../node_modules')\n                  ) === 0\n                )\n              }\n            }),\n            // extract webpack runtime and module manifest to its own file in order to\n            // prevent vendor hash from being updated whenever app bundle is updated\n            new webpack.optimize.CommonsChunkPlugin({\n              name: 'manifest',\n              chunks: ['vendor']\n            }),\n            \n            \n总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.\n           ","source":"_posts/webpack总结三.md","raw":"---\ntitle: webpack总结三\ndate: 2017-10-07 21:05:18\ntags:\n    - webpack\n---\n\n## 插件\nwebpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能\n如果是第三方插件,需要先安装\n\n### HtmlWebpackPlugin\n自动生成html插件,自动在dist目录下自动生成一个index.html\n<!-- more -->\n    \n     //webpack.config.js\n      var HtmlWebpackPlugin = require('html-webpack-plugin');\n      module.exports={\n        entry:'./index.js',\n        output:{\n          path:__dirname+'/dist',\n          filename:'bundle.js'\n        }\n        plugins:[\n          new HtmlWebpackPlugin()\n        ]\n      }\n      \n更多的配置\n      \n       plugins: [\n          new HtmlWebpackPlugin({\n            title: 'My App',\n            filename: 'admin.html',\n            template:'header.html',\n            inject: 'body',\n            favicon:'./images/favico.ico',\n            minify:true,\n            hash:true,\n            cache:false,\n            showErrors:false,\n            \"chunks\": {\n            \"head\": {\n              \"entry\": \"assets/head_bundle.js\",\n              \"css\": [ \"main.css\" ]\n            },\n            xhtml:false\n          })\n        ]\n\n### extract-text-webpack-plugin\n提取样式插件\n\n        var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n        new ExtractTextPlugin(\"[name].[hash].css\")\n        \n                \n## 优化插件\n需要在生产打包时进行额外的处理,比如压缩js代码.\n就要用到内置插件UgilifyJsPugin\n    \n        plugins:[\n            new webpack.optimize.UglifJsPlugin()\n        ]\n        \n在生产打包会有更多处理,在vue-cli中有以下配置\n        \n        new webpack.optimize.CommonsChunkPlugin({\n              name: 'vendor',\n              minChunks: function (module, count) {\n                // any required modules inside node_modules are extracted to vendor\n                return (\n                  module.resource &&\n                  /\\.js$/.test(module.resource) &&\n                  module.resource.indexOf(\n                    path.join(__dirname, '../node_modules')\n                  ) === 0\n                )\n              }\n            }),\n            // extract webpack runtime and module manifest to its own file in order to\n            // prevent vendor hash from being updated whenever app bundle is updated\n            new webpack.optimize.CommonsChunkPlugin({\n              name: 'manifest',\n              chunks: ['vendor']\n            }),\n            \n            \n总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.\n           ","slug":"webpack总结三","published":1,"updated":"2017-10-07T13:55:02.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8q1cpan00126ww3bpdwv1e2","content":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>webpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能<br>如果是第三方插件,需要先安装</p>\n<h3 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h3><p>自动生成html插件,自动在dist目录下自动生成一个index.html<br><a id=\"more\"></a></p>\n<pre><code>//webpack.config.js\n var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n module.exports={\n   entry:&apos;./index.js&apos;,\n   output:{\n     path:__dirname+&apos;/dist&apos;,\n     filename:&apos;bundle.js&apos;\n   }\n   plugins:[\n     new HtmlWebpackPlugin()\n   ]\n }\n</code></pre><p>更多的配置</p>\n<pre><code>plugins: [\n   new HtmlWebpackPlugin({\n     title: &apos;My App&apos;,\n     filename: &apos;admin.html&apos;,\n     template:&apos;header.html&apos;,\n     inject: &apos;body&apos;,\n     favicon:&apos;./images/favico.ico&apos;,\n     minify:true,\n     hash:true,\n     cache:false,\n     showErrors:false,\n     &quot;chunks&quot;: {\n     &quot;head&quot;: {\n       &quot;entry&quot;: &quot;assets/head_bundle.js&quot;,\n       &quot;css&quot;: [ &quot;main.css&quot; ]\n     },\n     xhtml:false\n   })\n ]\n</code></pre><h3 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h3><p>提取样式插件</p>\n<pre><code>var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nnew ExtractTextPlugin(&quot;[name].[hash].css&quot;)\n</code></pre><h2 id=\"优化插件\"><a href=\"#优化插件\" class=\"headerlink\" title=\"优化插件\"></a>优化插件</h2><p>需要在生产打包时进行额外的处理,比如压缩js代码.<br>就要用到内置插件UgilifyJsPugin</p>\n<pre><code>plugins:[\n    new webpack.optimize.UglifJsPlugin()\n]\n</code></pre><p>在生产打包会有更多处理,在vue-cli中有以下配置</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    }),\n</code></pre><p>总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>webpack有很多内置插件,也有第三方插件,用来拓展webpack相关功能<br>如果是第三方插件,需要先安装</p>\n<h3 id=\"HtmlWebpackPlugin\"><a href=\"#HtmlWebpackPlugin\" class=\"headerlink\" title=\"HtmlWebpackPlugin\"></a>HtmlWebpackPlugin</h3><p>自动生成html插件,自动在dist目录下自动生成一个index.html<br>","more":"</p>\n<pre><code>//webpack.config.js\n var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);\n module.exports={\n   entry:&apos;./index.js&apos;,\n   output:{\n     path:__dirname+&apos;/dist&apos;,\n     filename:&apos;bundle.js&apos;\n   }\n   plugins:[\n     new HtmlWebpackPlugin()\n   ]\n }\n</code></pre><p>更多的配置</p>\n<pre><code>plugins: [\n   new HtmlWebpackPlugin({\n     title: &apos;My App&apos;,\n     filename: &apos;admin.html&apos;,\n     template:&apos;header.html&apos;,\n     inject: &apos;body&apos;,\n     favicon:&apos;./images/favico.ico&apos;,\n     minify:true,\n     hash:true,\n     cache:false,\n     showErrors:false,\n     &quot;chunks&quot;: {\n     &quot;head&quot;: {\n       &quot;entry&quot;: &quot;assets/head_bundle.js&quot;,\n       &quot;css&quot;: [ &quot;main.css&quot; ]\n     },\n     xhtml:false\n   })\n ]\n</code></pre><h3 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h3><p>提取样式插件</p>\n<pre><code>var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);\nnew ExtractTextPlugin(&quot;[name].[hash].css&quot;)\n</code></pre><h2 id=\"优化插件\"><a href=\"#优化插件\" class=\"headerlink\" title=\"优化插件\"></a>优化插件</h2><p>需要在生产打包时进行额外的处理,比如压缩js代码.<br>就要用到内置插件UgilifyJsPugin</p>\n<pre><code>plugins:[\n    new webpack.optimize.UglifJsPlugin()\n]\n</code></pre><p>在生产打包会有更多处理,在vue-cli中有以下配置</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;vendor&apos;,\n      minChunks: function (module, count) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &amp;&amp;\n          /\\.js$/.test(module.resource) &amp;&amp;\n          module.resource.indexOf(\n            path.join(__dirname, &apos;../node_modules&apos;)\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: &apos;manifest&apos;,\n      chunks: [&apos;vendor&apos;]\n    }),\n</code></pre><p>总之,webpack配置还挺复杂,值得弄明白,听说以前还有专门的webpack岗位,下面还会就vue-cli这种专业的配置总结一下.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8q1cp8h00006ww35osy782b","tag_id":"cj8q1cp8h00026ww37xvo60gg","_id":"cj8q1cp8w00076ww3gtrmr9nt"},{"post_id":"cj8q1cp8h00016ww3upfnpyj3","tag_id":"cj8q1cp8w00066ww39zvhrwxl","_id":"cj8q1cp9c000d6ww3nopd2u2m"},{"post_id":"cj8q1cp8h00016ww3upfnpyj3","tag_id":"cj8q1cp9c000a6ww3x1ugo8xv","_id":"cj8q1cp9c000e6ww3fxnrmr70"},{"post_id":"cj8q1cp8w00036ww37rhjitco","tag_id":"cj8q1cp9c000c6ww3jzhyr6xe","_id":"cj8q1cp9c000g6ww3cj9jpnd0"},{"post_id":"cj8q1cp8w00046ww3lertgpfh","tag_id":"cj8q1cp9c000f6ww3tw2lz2hg","_id":"cj8q1cp9c000i6ww37dlbdf35"},{"post_id":"cj8q1cp8w00056ww3tdg51tr7","tag_id":"cj8q1cp9c000h6ww30quq8uy6","_id":"cj8q1cp9c000k6ww357jwlv85"},{"post_id":"cj8q1cp8w00086ww35fnk24lk","tag_id":"cj8q1cp8w00066ww39zvhrwxl","_id":"cj8q1cp9c000n6ww3ykm6nu5i"},{"post_id":"cj8q1cp8w00086ww35fnk24lk","tag_id":"cj8q1cp9c000a6ww3x1ugo8xv","_id":"cj8q1cp9c000o6ww3vg977wsm"},{"post_id":"cj8q1cp8w00086ww35fnk24lk","tag_id":"cj8q1cp9c000l6ww32xm4he8t","_id":"cj8q1cp9c000q6ww3pxyeicfz"},{"post_id":"cj8q1cp8w00096ww3yvto7nx5","tag_id":"cj8q1cp9c000m6ww38181bbrt","_id":"cj8q1cp9r000r6ww3pcsxtjhj"},{"post_id":"cj8q1cp9c000b6ww3nzcha2o2","tag_id":"cj8q1cp8w00066ww39zvhrwxl","_id":"cj8q1cp9r000t6ww3gi97v0wn"},{"post_id":"cj8q1cp9c000b6ww3nzcha2o2","tag_id":"cj8q1cp9c000p6ww3dy3hdxyy","_id":"cj8q1cp9r000u6ww3506i2gf4"},{"post_id":"cj8q1cp9c000b6ww3nzcha2o2","tag_id":"cj8q1cp9r000s6ww373500672","_id":"cj8q1cp9r000v6ww36of8giwl"},{"post_id":"cj8q1cp9c000b6ww3nzcha2o2","tag_id":"cj8q1cp9c000a6ww3x1ugo8xv","_id":"cj8q1cp9r000w6ww3be0sl593"},{"post_id":"cj8q1cp9r000y6ww3rvih09fn","tag_id":"cj8q1cp9c000m6ww38181bbrt","_id":"cj8q1cp9r00106ww3gogkqueg"},{"post_id":"cj8q1cp9r000x6ww3n3clqjg4","tag_id":"cj8q1cp9r000z6ww3siu74owa","_id":"cj8q1cp9r00116ww3rx875f56"},{"post_id":"cj8q1cpan00126ww3bpdwv1e2","tag_id":"cj8q1cp9c000a6ww3x1ugo8xv","_id":"cj8q1cpan00136ww37locg9uc"}],"Tag":[{"name":"-swiper-animate","_id":"cj8q1cp8h00026ww37xvo60gg"},{"name":"vue-cli","_id":"cj8q1cp8w00066ww39zvhrwxl"},{"name":"webpack","_id":"cj8q1cp9c000a6ww3x1ugo8xv"},{"name":"-hexo -AppVeyor -持续集成","_id":"cj8q1cp9c000c6ww3jzhyr6xe"},{"name":"-跨域 -jsonp -promise -异步同步","_id":"cj8q1cp9c000f6ww3tw2lz2hg"},{"name":"-webpack -vue-cli -vue","_id":"cj8q1cp9c000h6ww30quq8uy6"},{"name":"nodejs","_id":"cj8q1cp9c000l6ww32xm4he8t"},{"name":"-webpack","_id":"cj8q1cp9c000m6ww38181bbrt"},{"name":"node","_id":"cj8q1cp9c000p6ww3dy3hdxyy"},{"name":"vue","_id":"cj8q1cp9r000s6ww373500672"},{"name":"-跨域 -代理","_id":"cj8q1cp9r000z6ww3siu74owa"}]}}